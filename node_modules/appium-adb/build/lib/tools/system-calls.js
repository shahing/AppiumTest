"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ADB_EXEC_TIMEOUT = exports.default = void 0;

require("source-map-support/register");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("../logger.js"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumSupport = require("appium-support");

var _helpers = require("../helpers");

var _teen_process = require("teen_process");

var _asyncbox = require("asyncbox");

var _lodash = _interopRequireDefault(require("lodash"));

var _shellQuote = require("shell-quote");

let systemCallMethods = {};
const DEFAULT_ADB_EXEC_TIMEOUT = 20000;
exports.DEFAULT_ADB_EXEC_TIMEOUT = DEFAULT_ADB_EXEC_TIMEOUT;
const DEFAULT_ADB_REBOOT_RETRIES = 90;
const LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;
const PROTOCOL_FAULT_ERROR_REGEXP = new RegExp('protocol fault \\(no status\\)', 'i');
const DEVICE_NOT_FOUND_ERROR_REGEXP = new RegExp(`error: device ('.+' )?not found`, 'i');
const DEVICE_CONNECTING_ERROR_REGEXP = new RegExp('error: device still connecting', 'i');
const CERTS_ROOT = '/system/etc/security/cacerts';
systemCallMethods.getSdkBinaryPath = _lodash.default.memoize(async function (binaryName) {
  _logger.default.info(`Checking whether ${binaryName} is present`);

  if (this.sdkRoot) {
    return await this.getBinaryFromSdkRoot(binaryName);
  }

  _logger.default.warn(`The ANDROID_HOME environment variable is not set to the Android SDK ` + `root directory path. ANDROID_HOME is required for compatibility ` + `with SDK 23+. Checking along PATH for ${binaryName}.`);

  return await this.getBinaryFromPath(binaryName);
});
systemCallMethods.getCommandForOS = _lodash.default.memoize(function () {
  return _appiumSupport.system.isWindows() ? 'where' : 'which';
});
systemCallMethods.getBinaryNameForOS = _lodash.default.memoize(function (binaryName) {
  if (!_appiumSupport.system.isWindows()) {
    return binaryName;
  }

  if (['android', 'apksigner', 'apkanalyzer'].indexOf(binaryName) >= 0 && !binaryName.toLowerCase().endsWith('.bat')) {
    return `${binaryName}.bat`;
  }

  if (!binaryName.toLowerCase().endsWith('.exe')) {
    return `${binaryName}.exe`;
  }

  return binaryName;
});
systemCallMethods.getBinaryFromSdkRoot = _lodash.default.memoize(async function (binaryName) {
  let binaryLoc = null;
  binaryName = this.getBinaryNameForOS(binaryName);
  let binaryLocs = [_path.default.resolve(this.sdkRoot, 'platform-tools', binaryName), _path.default.resolve(this.sdkRoot, 'emulator', binaryName), _path.default.resolve(this.sdkRoot, 'tools', binaryName), _path.default.resolve(this.sdkRoot, 'tools', 'bin', binaryName)];

  _lodash.default.forEach((await (0, _helpers.getBuildToolsDirs)(this.sdkRoot)), dir => binaryLocs.push(_path.default.resolve(dir, binaryName)));

  for (let loc of binaryLocs) {
    if (await _appiumSupport.fs.exists(loc)) {
      binaryLoc = loc;
      break;
    }
  }

  if (_lodash.default.isNull(binaryLoc)) {
    throw new Error(`Could not find ${binaryName} in ${binaryLocs}. ` + `Do you have the Android SDK installed at '${this.sdkRoot}'?`);
  }

  binaryLoc = binaryLoc.trim();

  _logger.default.info(`Using ${binaryName} from ${binaryLoc}`);

  return binaryLoc;
});

systemCallMethods.getBinaryFromPath = async function (binaryName) {
  let binaryLoc = null;
  let cmd = this.getCommandForOS();

  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(cmd, [binaryName]);

    _logger.default.info(`Using ${binaryName} from ${stdout}`);

    binaryLoc = stdout.trim();
    return binaryLoc;
  } catch (e) {
    throw new Error(`Could not find ${binaryName} Please set the ANDROID_HOME ` + `environment variable with the Android SDK root directory path.`);
  }
};

systemCallMethods.getConnectedDevices = async function () {
  _logger.default.debug('Getting connected devices...');

  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, this.executable.defaultArgs.concat(['devices']));
    let startingIndex = stdout.indexOf('List of devices');

    if (startingIndex === -1) {
      throw new Error(`Unexpected output while trying to get devices. output was: ${stdout}`);
    }

    stdout = stdout.slice(startingIndex);
    let devices = [];

    for (let line of stdout.split('\n')) {
      if (line.trim() !== '' && line.indexOf('List of devices') === -1 && line.indexOf('adb server') === -1 && line.indexOf('* daemon') === -1 && line.indexOf('offline') === -1) {
        let lineInfo = line.split('\t');
        devices.push({
          udid: lineInfo[0],
          state: lineInfo[1]
        });
      }
    }

    _logger.default.debug(`${devices.length} device(s) connected`);

    return devices;
  } catch (e) {
    throw new Error(`Error while getting connected devices. Original error: ${e.message}`);
  }
};

systemCallMethods.getDevicesWithRetry = async function (timeoutMs = 20000) {
  let start = Date.now();

  _logger.default.debug('Trying to find a connected android device');

  let getDevices = async () => {
    if (Date.now() - start > timeoutMs) {
      throw new Error('Could not find a connected Android device.');
    }

    try {
      let devices = await this.getConnectedDevices();

      if (devices.length < 1) {
        _logger.default.debug('Could not find devices, restarting adb server...');

        await this.restartAdb();
        await (0, _asyncbox.sleep)(200);
        return await getDevices();
      }

      return devices;
    } catch (e) {
      _logger.default.debug('Could not find devices, restarting adb server...');

      await this.restartAdb();
      await (0, _asyncbox.sleep)(200);
      return await getDevices();
    }
  };

  return await getDevices();
};

systemCallMethods.restartAdb = async function () {
  if (this.suppressKillServer) {
    _logger.default.debug(`Not restarting abd since 'suppressKillServer' is on`);

    return;
  }

  _logger.default.debug('Restarting adb');

  try {
    await this.killServer();
  } catch (e) {
    _logger.default.error("Error killing ADB server, going to see if it's online anyway");
  }
};

systemCallMethods.killServer = async function () {
  _logger.default.debug(`Killing adb server on port ${this.adbPort}`);

  await (0, _teen_process.exec)(this.executable.path, [...this.executable.defaultArgs, 'kill-server']);
};

systemCallMethods.resetTelnetAuthToken = _lodash.default.memoize(async function () {
  const homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

  if (!homeFolderPath) {
    _logger.default.warn(`Cannot find the path to user home folder. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  const dstPath = _path.default.resolve(homeFolderPath, '.emulator_console_auth_token');

  _logger.default.debug(`Overriding ${dstPath} with an empty string to avoid telnet authentication for emulator commands`);

  try {
    await _appiumSupport.fs.writeFile(dstPath, '');
  } catch (e) {
    _logger.default.warn(`Error ${e.message} while resetting the content of ${dstPath}. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  return true;
});

systemCallMethods.adbExecEmu = async function (cmd) {
  await this.verifyEmulatorConnected();
  await this.resetTelnetAuthToken();
  await this.adbExec(['emu', ...cmd]);
};

systemCallMethods.adbExec = async function (cmd, opts = {}) {
  if (!cmd) {
    throw new Error('You need to pass in a command to adbExec()');
  }

  opts.timeout = opts.timeout || this.adbExecTimeout || DEFAULT_ADB_EXEC_TIMEOUT;
  cmd = _lodash.default.isArray(cmd) ? cmd : [cmd];
  let adbRetried = false;

  const execFunc = async () => {
    try {
      const args = this.executable.defaultArgs.concat(cmd);

      _logger.default.debug(`Running '${this.executable.path} ${(0, _shellQuote.quote)(args)}'`);

      let {
        stdout
      } = await (0, _teen_process.exec)(this.executable.path, args, opts);
      stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      return stdout;
    } catch (e) {
      const errText = `${e.message}, ${e.stdout}, ${e.stderr}`;
      const protocolFaultError = PROTOCOL_FAULT_ERROR_REGEXP.test(errText);
      const deviceNotFoundError = DEVICE_NOT_FOUND_ERROR_REGEXP.test(errText);
      const deviceConnectingError = DEVICE_CONNECTING_ERROR_REGEXP.test(errText);

      if (protocolFaultError || deviceNotFoundError || deviceConnectingError) {
        _logger.default.info(`Error sending command, reconnecting device and retrying: ${cmd}`);

        await (0, _asyncbox.sleep)(1000);
        await this.getDevicesWithRetry();

        if (adbRetried) {
          adbRetried = true;
          return await execFunc();
        }
      }

      if (e.code === 0 && e.stdout) {
        return e.stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      }

      if (_lodash.default.isNull(e.code)) {
        e.message = `Error executing adbExec. Original error: '${e.message}'. ` + `Try to increase the ${opts.timeout}ms adb execution timeout represented by 'adbExecTimeout' capability`;
      } else {
        e.message = `Error executing adbExec. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`;
      }

      throw e;
    }
  };

  return await execFunc();
};

systemCallMethods.shell = async function (cmd, opts = {}) {
  const {
    privileged,
    keepPrivileged
  } = opts;
  let shouldRestoreUser = false;

  if (privileged) {
    try {
      shouldRestoreUser = !(await this.adbExec(['root'], opts)).includes('already running as root');
    } catch (err) {
      if (!err.message.includes('adbd cannot run as root')) {
        _logger.default.warn(`Cannot run adbd as root. Original error: ${err.message}`);
      }
    }
  }

  let didCommandFail = false;

  try {
    try {
      return await this.adbExec(_lodash.default.isArray(cmd) ? ['shell', ...cmd] : ['shell', cmd], opts);
    } catch (err) {
      didCommandFail = true;
      throw err;
    }
  } finally {
    if (privileged && shouldRestoreUser && (!keepPrivileged || didCommandFail)) {
      try {
        await this.adbExec(['unroot'], opts);
      } catch (err) {
        _logger.default.warn(`Cannot run adbd as non-root. Original error: ${err.message}`);
      }
    }
  }
};

systemCallMethods.createSubProcess = function (args = []) {
  args = this.executable.defaultArgs.concat(args);

  _logger.default.debug(`Creating ADB subprocess with args: ${JSON.stringify(args)}`);

  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

systemCallMethods.getAdbServerPort = function () {
  return this.adbPort;
};

systemCallMethods.getEmulatorPort = async function () {
  _logger.default.debug('Getting running emulator port');

  if (this.emulatorPort !== null) {
    return this.emulatorPort;
  }

  try {
    let devices = await this.getConnectedDevices();
    let port = this.getPortFromEmulatorString(devices[0].udid);

    if (port) {
      return port;
    } else {
      throw new Error(`Emulator port not found`);
    }
  } catch (e) {
    throw new Error(`No devices connected. Original error: ${e.message}`);
  }
};

systemCallMethods.getPortFromEmulatorString = function (emStr) {
  let portPattern = /emulator-(\d+)/;

  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }

  return false;
};

systemCallMethods.getConnectedEmulators = async function () {
  _logger.default.debug('Getting connected emulators');

  try {
    let devices = await this.getConnectedDevices();
    let emulators = [];

    for (let device of devices) {
      let port = this.getPortFromEmulatorString(device.udid);

      if (port) {
        device.port = port;
        emulators.push(device);
      }
    }

    _logger.default.debug(`${emulators.length} emulator(s) connected`);

    return emulators;
  } catch (e) {
    throw new Error(`Error getting emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.setEmulatorPort = function (emPort) {
  this.emulatorPort = emPort;
};

systemCallMethods.setDeviceId = function (deviceId) {
  _logger.default.debug(`Setting device id to ${deviceId}`);

  this.curDeviceId = deviceId;
  let argsHasDevice = this.executable.defaultArgs.indexOf('-s');

  if (argsHasDevice !== -1) {
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }

  this.executable.defaultArgs.push('-s', deviceId);
};

systemCallMethods.setDevice = function (deviceObj) {
  let deviceId = deviceObj.udid;
  let emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

systemCallMethods.getRunningAVD = async function (avdName) {
  _logger.default.debug(`Trying to find ${avdName} emulator`);

  try {
    let emulators = await this.getConnectedEmulators();

    for (let emulator of emulators) {
      this.setEmulatorPort(emulator.port);
      let runningAVDName = await this.sendTelnetCommand('avd name');

      if (avdName === runningAVDName) {
        _logger.default.debug(`Found emulator ${avdName} in port ${emulator.port}`);

        this.setDeviceId(emulator.udid);
        return emulator;
      }
    }

    _logger.default.debug(`Emulator ${avdName} not running`);

    return null;
  } catch (e) {
    throw new Error(`Error getting AVD. Original error: ${e.message}`);
  }
};

systemCallMethods.getRunningAVDWithRetry = async function (avdName, timeoutMs = 20000) {
  let runningAvd;

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        runningAvd = await this.getRunningAVD(avdName.replace('@', ''));
        return runningAvd;
      } catch (e) {
        _logger.default.debug(e.message);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 1000
    });
  } catch (e) {
    throw new Error(`Error getting AVD with retry. Original error: ${e.message}`);
  }

  return runningAvd;
};

systemCallMethods.killAllEmulators = async function () {
  let cmd, args;

  if (_appiumSupport.system.isWindows()) {
    cmd = 'TASKKILL';
    args = ['TASKKILL', '/IM', 'emulator.exe'];
  } else {
    cmd = '/usr/bin/killall';
    args = ['-m', 'emulator*'];
  }

  try {
    await (0, _teen_process.exec)(cmd, args);
  } catch (e) {
    throw new Error(`Error killing emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.killEmulator = async function (avdName = null, timeout = 60000) {
  if (_appiumSupport.util.hasValue(avdName)) {
    _logger.default.debug(`Killing avd '${avdName}'`);

    const device = await this.getRunningAVD(avdName);

    if (!device) {
      _logger.default.info(`No avd with name '${avdName}' running. Skipping kill step.`);

      return false;
    }
  } else {
    _logger.default.debug(`Killing avd with id '${this.curDeviceId}'`);

    if (!(await this.isEmulatorConnected())) {
      _logger.default.debug(`Emulator with id '${this.curDeviceId}' not connected. Skipping kill step`);

      return false;
    }
  }

  await this.adbExec(['emu', 'kill']);

  _logger.default.debug(`Waiting up to ${timeout}ms until the emulator '${avdName ? avdName : this.curDeviceId}' is killed`);

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        return _appiumSupport.util.hasValue(avdName) ? !(await this.getRunningAVD(avdName)) : !(await this.isEmulatorConnected());
      } catch (ign) {}

      return false;
    }, {
      waitMs: timeout,
      intervalMs: 2000
    });
  } catch (e) {
    throw new Error(`The emulator '${avdName ? avdName : this.curDeviceId}' is still running after being killed ${timeout}ms ago`);
  }

  _logger.default.info(`Successfully killed the '${avdName ? avdName : this.curDeviceId}' emulator`);

  return true;
};

systemCallMethods.launchAVD = async function (avdName, avdArgs, language, country, avdLaunchTimeout = 60000, avdReadyTimeout = 60000, retryTimes = 1) {
  _logger.default.debug(`Launching Emulator with AVD ${avdName}, launchTimeout ` + `${avdLaunchTimeout}ms and readyTimeout ${avdReadyTimeout}ms`);

  let emulatorBinaryPath = await this.getSdkBinaryPath('emulator');

  if (avdName[0] === '@') {
    avdName = avdName.substr(1);
  }

  await this.checkAvdExist(avdName);
  let launchArgs = ['-avd', avdName];

  if (_lodash.default.isString(language)) {
    _logger.default.debug(`Setting Android Device Language to ${language}`);

    launchArgs.push('-prop', `persist.sys.language=${language.toLowerCase()}`);
  }

  if (_lodash.default.isString(country)) {
    _logger.default.debug(`Setting Android Device Country to ${country}`);

    launchArgs.push('-prop', `persist.sys.country=${country.toUpperCase()}`);
  }

  let locale;

  if (_lodash.default.isString(language) && _lodash.default.isString(country)) {
    locale = language.toLowerCase() + '-' + country.toUpperCase();
  } else if (_lodash.default.isString(language)) {
    locale = language.toLowerCase();
  } else if (_lodash.default.isString(country)) {
    locale = country;
  }

  if (_lodash.default.isString(locale)) {
    _logger.default.debug(`Setting Android Device Locale to ${locale}`);

    launchArgs.push('-prop', `persist.sys.locale=${locale}`);
  }

  if (!_lodash.default.isEmpty(avdArgs)) {
    launchArgs.push(...(_lodash.default.isArray(avdArgs) ? avdArgs : avdArgs.split(' ')));
  }

  _logger.default.debug(`Running '${emulatorBinaryPath}' with args: ${JSON.stringify(launchArgs)}`);

  let proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs);
  await proc.start(0);
  proc.on('output', (stdout, stderr) => {
    for (let line of (stdout || stderr || '').split('\n').filter(Boolean)) {
      _logger.default.info(`[AVD OUTPUT] ${line}`);
    }
  });
  proc.on('die', (code, signal) => {
    _logger.default.warn(`Emulator avd ${avdName} exited with code ${code}${signal ? `, signal ${signal}` : ''}`);
  });
  await (0, _asyncbox.retry)(retryTimes, async () => await this.getRunningAVDWithRetry(avdName, avdLaunchTimeout));
  await this.waitForEmulatorReady(avdReadyTimeout);
  return proc;
};

systemCallMethods.getAdbVersion = _lodash.default.memoize(async function () {
  try {
    let adbVersion = (await this.adbExec('version')).replace(/Android\sDebug\sBridge\sversion\s([\d.]*)[\s\w-]*/, '$1');
    let parts = adbVersion.split('.');
    return {
      versionString: adbVersion,
      versionFloat: parseFloat(adbVersion),
      major: parseInt(parts[0], 10),
      minor: parseInt(parts[1], 10),
      patch: parts[2] ? parseInt(parts[2], 10) : undefined
    };
  } catch (e) {
    throw new Error(`Error getting adb version. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
  }
});

systemCallMethods.checkAvdExist = async function (avdName) {
  let cmd, result;

  try {
    cmd = await this.getSdkBinaryPath('emulator');
    result = await (0, _teen_process.exec)(cmd, ['-list-avds']);
  } catch (e) {
    let unknownOptionError = new RegExp('unknown option: -list-avds', 'i').test(e.stderr);

    if (!unknownOptionError) {
      throw new Error(`Error executing checkAvdExist. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
    }

    const sdkVersion = await (0, _helpers.getSdkToolsVersion)();
    let binaryName = 'android';

    if (sdkVersion) {
      if (sdkVersion.major >= 25) {
        binaryName = 'avdmanager';
      }
    } else {
      _logger.default.warn(`Defaulting binary name to '${binaryName}', because SDK version cannot be parsed`);
    }

    cmd = await this.getSdkBinaryPath(binaryName);
    result = await (0, _teen_process.exec)(cmd, ['list', 'avd', '-c']);
  }

  if (result.stdout.indexOf(avdName) === -1) {
    let existings = `(${result.stdout.trim().replace(/[\n]/g, '), (')})`;
    throw new Error(`Avd '${avdName}' is not available. please select your avd name from one of these: '${existings}'`);
  }
};

systemCallMethods.waitForEmulatorReady = async function (timeoutMs = 20000) {
  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        if (!(await this.shell(['getprop', 'init.svc.bootanim'])).includes('stopped')) {
          return false;
        }

        return /\d+\[\w+\]/.test((await this.shell(['pm', 'get-install-location'])));
      } catch (err) {
        _logger.default.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 3000
    });
  } catch (e) {
    throw new Error(`Emulator is not ready within ${timeoutMs}ms`);
  }
};

systemCallMethods.waitForDevice = async function (appDeviceReadyTimeout = 30) {
  this.appDeviceReadyTimeout = appDeviceReadyTimeout;
  const retries = 3;
  const timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
  await (0, _asyncbox.retry)(retries, async () => {
    try {
      await this.adbExec('wait-for-device', {
        timeout
      });
      await this.ping();
    } catch (e) {
      await this.restartAdb();
      await this.getConnectedDevices();
      throw new Error(`Error waiting for the device to be available. Original error: '${e.message}'`);
    }
  });
};

systemCallMethods.reboot = async function (retries = DEFAULT_ADB_REBOOT_RETRIES) {
  await this.shell(['stop'], {
    privileged: true
  });
  await _bluebird.default.delay(2000);
  await this.setDeviceProperty('sys.boot_completed', 0);
  await this.shell(['start'], {
    privileged: true
  });
  const started = process.hrtime();
  await (0, _asyncbox.retryInterval)(retries, 1000, async () => {
    if ((await this.getDeviceProperty('sys.boot_completed')) === '1') {
      return;
    }

    const msg = `Reboot is not completed after ${process.hrtime(started)[0]}s`;

    _logger.default.debug(msg);

    throw new Error(msg);
  });
};

systemCallMethods.root = async function () {
  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, ['root']);

    if (stdout && stdout.indexOf('adbd cannot run as root') !== -1) {
      throw new Error(stdout.trim());
    }

    return true;
  } catch (err) {
    _logger.default.warn(`Unable to root adb daemon: '${err.message}'. Continuing`);

    return false;
  }
};

systemCallMethods.unroot = async function () {
  try {
    await (0, _teen_process.exec)(this.executable.path, ['unroot']);
    return true;
  } catch (err) {
    _logger.default.warn(`Unable to unroot adb daemon: '${err.message}'. Continuing`);

    return false;
  }
};

systemCallMethods.isRoot = async function () {
  return (await this.shell(['whoami'])).trim() === 'root';
};

systemCallMethods.fileExists = async function (remotePath) {
  let files = await this.ls(remotePath);
  return files.length > 0;
};

systemCallMethods.ls = async function (remotePath, opts = []) {
  try {
    let args = ['ls', ...opts, remotePath];
    let stdout = await this.shell(args);
    let lines = stdout.split('\n');
    return lines.map(l => l.trim()).filter(Boolean).filter(l => l.indexOf('No such file') === -1);
  } catch (err) {
    if (err.message.indexOf('No such file or directory') === -1) {
      throw err;
    }

    return [];
  }
};

systemCallMethods.fileSize = async function (remotePath) {
  try {
    const files = await this.ls(remotePath, ['-la']);

    if (files.length !== 1) {
      throw new Error(`Remote path is not a file`);
    }

    const match = /[rwxsStT\-+]{10}[\s\d]*\s[^\s]+\s+[^\s]+\s+(\d+)/.exec(files[0]);

    if (!match || _lodash.default.isNaN(parseInt(match[1], 10))) {
      throw new Error(`Unable to parse size from list output: '${files[0]}'`);
    }

    return parseInt(match[1], 10);
  } catch (err) {
    throw new Error(`Unable to get file size for '${remotePath}': ${err.message}`);
  }
};

systemCallMethods.installMitmCertificate = async function (cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();

  try {
    const srcCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(srcCert, cert);
    let {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]);
    const certHash = stdout.trim();

    _logger.default.debug(`Got certificate hash: ${certHash}`);

    _logger.default.debug('Preparing certificate content');

    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert], {
      isBuffer: true
    }));
    let dstCertContent = stdout;
    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert, '-text', '-fingerprint', '-noout'], {
      isBuffer: true
    }));
    dstCertContent = Buffer.concat([dstCertContent, stdout]);

    const dstCert = _path.default.resolve(tmpRoot, `${certHash}.0`);

    await _appiumSupport.fs.writeFile(dstCert, dstCertContent);

    _logger.default.debug('Remounting /system in rw mode');

    await (0, _asyncbox.retryInterval)(5, 2000, async () => await this.adbExec(['remount']));

    _logger.default.debug(`Uploading the generated certificate from '${dstCert}' to '${CERTS_ROOT}'`);

    await this.push(dstCert, CERTS_ROOT);

    _logger.default.debug('Remounting /system to confirm changes');

    await this.adbExec(['remount']);
  } catch (err) {
    throw new Error(`Cannot inject the custom certificate. ` + `Is the certificate properly encoded into base64-string? ` + `Do you have root permissions on the device? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }
};

systemCallMethods.isMitmCertificateInstalled = async function (cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();
  let certHash;

  try {
    const tmpCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(tmpCert, cert);
    const {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]);
    certHash = stdout.trim();
  } catch (err) {
    throw new Error(`Cannot retrieve the certificate hash. ` + `Is the certificate properly encoded into base64-string? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }

  const dstPath = _path.default.posix.resolve(CERTS_ROOT, `${certHash}.0`);

  _logger.default.debug(`Checking if the certificate is already installed at '${dstPath}'`);

  return await this.fileExists(dstPath);
};

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOlsic3lzdGVtQ2FsbE1ldGhvZHMiLCJERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQiLCJERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyIsIkxJTktFUl9XQVJOSU5HX1JFR0VYUCIsIlBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUCIsIlJlZ0V4cCIsIkRFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQIiwiREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQIiwiQ0VSVFNfUk9PVCIsImdldFNka0JpbmFyeVBhdGgiLCJfIiwibWVtb2l6ZSIsImJpbmFyeU5hbWUiLCJsb2ciLCJpbmZvIiwic2RrUm9vdCIsImdldEJpbmFyeUZyb21TZGtSb290Iiwid2FybiIsImdldEJpbmFyeUZyb21QYXRoIiwiZ2V0Q29tbWFuZEZvck9TIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwiZ2V0QmluYXJ5TmFtZUZvck9TIiwiaW5kZXhPZiIsInRvTG93ZXJDYXNlIiwiZW5kc1dpdGgiLCJiaW5hcnlMb2MiLCJiaW5hcnlMb2NzIiwicGF0aCIsInJlc29sdmUiLCJmb3JFYWNoIiwiZGlyIiwicHVzaCIsImxvYyIsImZzIiwiZXhpc3RzIiwiaXNOdWxsIiwiRXJyb3IiLCJ0cmltIiwiY21kIiwic3Rkb3V0IiwiZSIsImdldENvbm5lY3RlZERldmljZXMiLCJkZWJ1ZyIsImV4ZWN1dGFibGUiLCJkZWZhdWx0QXJncyIsImNvbmNhdCIsInN0YXJ0aW5nSW5kZXgiLCJzbGljZSIsImRldmljZXMiLCJsaW5lIiwic3BsaXQiLCJsaW5lSW5mbyIsInVkaWQiLCJzdGF0ZSIsImxlbmd0aCIsIm1lc3NhZ2UiLCJnZXREZXZpY2VzV2l0aFJldHJ5IiwidGltZW91dE1zIiwic3RhcnQiLCJEYXRlIiwibm93IiwiZ2V0RGV2aWNlcyIsInJlc3RhcnRBZGIiLCJzdXBwcmVzc0tpbGxTZXJ2ZXIiLCJraWxsU2VydmVyIiwiZXJyb3IiLCJhZGJQb3J0IiwicmVzZXRUZWxuZXRBdXRoVG9rZW4iLCJob21lRm9sZGVyUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJwbGF0Zm9ybSIsImRzdFBhdGgiLCJ3cml0ZUZpbGUiLCJhZGJFeGVjRW11IiwidmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQiLCJhZGJFeGVjIiwib3B0cyIsInRpbWVvdXQiLCJhZGJFeGVjVGltZW91dCIsImlzQXJyYXkiLCJhZGJSZXRyaWVkIiwiZXhlY0Z1bmMiLCJhcmdzIiwicmVwbGFjZSIsImVyclRleHQiLCJzdGRlcnIiLCJwcm90b2NvbEZhdWx0RXJyb3IiLCJ0ZXN0IiwiZGV2aWNlTm90Rm91bmRFcnJvciIsImRldmljZUNvbm5lY3RpbmdFcnJvciIsImNvZGUiLCJzaGVsbCIsInByaXZpbGVnZWQiLCJrZWVwUHJpdmlsZWdlZCIsInNob3VsZFJlc3RvcmVVc2VyIiwiaW5jbHVkZXMiLCJlcnIiLCJkaWRDb21tYW5kRmFpbCIsImNyZWF0ZVN1YlByb2Nlc3MiLCJKU09OIiwic3RyaW5naWZ5IiwiU3ViUHJvY2VzcyIsImdldEFkYlBhdGgiLCJnZXRBZGJTZXJ2ZXJQb3J0IiwiZ2V0RW11bGF0b3JQb3J0IiwiZW11bGF0b3JQb3J0IiwicG9ydCIsImdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmciLCJlbVN0ciIsInBvcnRQYXR0ZXJuIiwicGFyc2VJbnQiLCJleGVjIiwiZ2V0Q29ubmVjdGVkRW11bGF0b3JzIiwiZW11bGF0b3JzIiwiZGV2aWNlIiwic2V0RW11bGF0b3JQb3J0IiwiZW1Qb3J0Iiwic2V0RGV2aWNlSWQiLCJkZXZpY2VJZCIsImN1ckRldmljZUlkIiwiYXJnc0hhc0RldmljZSIsInNwbGljZSIsInNldERldmljZSIsImRldmljZU9iaiIsImdldFJ1bm5pbmdBVkQiLCJhdmROYW1lIiwiZW11bGF0b3IiLCJydW5uaW5nQVZETmFtZSIsInNlbmRUZWxuZXRDb21tYW5kIiwiZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSIsInJ1bm5pbmdBdmQiLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIiwia2lsbEFsbEVtdWxhdG9ycyIsImtpbGxFbXVsYXRvciIsInV0aWwiLCJoYXNWYWx1ZSIsImlzRW11bGF0b3JDb25uZWN0ZWQiLCJpZ24iLCJsYXVuY2hBVkQiLCJhdmRBcmdzIiwibGFuZ3VhZ2UiLCJjb3VudHJ5IiwiYXZkTGF1bmNoVGltZW91dCIsImF2ZFJlYWR5VGltZW91dCIsInJldHJ5VGltZXMiLCJlbXVsYXRvckJpbmFyeVBhdGgiLCJzdWJzdHIiLCJjaGVja0F2ZEV4aXN0IiwibGF1bmNoQXJncyIsImlzU3RyaW5nIiwidG9VcHBlckNhc2UiLCJsb2NhbGUiLCJpc0VtcHR5IiwicHJvYyIsIm9uIiwiZmlsdGVyIiwiQm9vbGVhbiIsInNpZ25hbCIsIndhaXRGb3JFbXVsYXRvclJlYWR5IiwiZ2V0QWRiVmVyc2lvbiIsImFkYlZlcnNpb24iLCJwYXJ0cyIsInZlcnNpb25TdHJpbmciLCJ2ZXJzaW9uRmxvYXQiLCJwYXJzZUZsb2F0IiwibWFqb3IiLCJtaW5vciIsInBhdGNoIiwidW5kZWZpbmVkIiwicmVzdWx0IiwidW5rbm93bk9wdGlvbkVycm9yIiwic2RrVmVyc2lvbiIsImV4aXN0aW5ncyIsIndhaXRGb3JEZXZpY2UiLCJhcHBEZXZpY2VSZWFkeVRpbWVvdXQiLCJyZXRyaWVzIiwicGluZyIsInJlYm9vdCIsIkIiLCJkZWxheSIsInNldERldmljZVByb3BlcnR5Iiwic3RhcnRlZCIsImhydGltZSIsImdldERldmljZVByb3BlcnR5IiwibXNnIiwicm9vdCIsInVucm9vdCIsImlzUm9vdCIsImZpbGVFeGlzdHMiLCJyZW1vdGVQYXRoIiwiZmlsZXMiLCJscyIsImxpbmVzIiwibWFwIiwibCIsImZpbGVTaXplIiwibWF0Y2giLCJpc05hTiIsImluc3RhbGxNaXRtQ2VydGlmaWNhdGUiLCJjZXJ0Iiwib3BlblNzbCIsImlzQnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsInRtcFJvb3QiLCJ0ZW1wRGlyIiwib3BlbkRpciIsInNyY0NlcnQiLCJjZXJ0SGFzaCIsImRzdENlcnRDb250ZW50IiwiZHN0Q2VydCIsInJpbXJhZiIsImlzTWl0bUNlcnRpZmljYXRlSW5zdGFsbGVkIiwidG1wQ2VydCIsInBvc2l4Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLElBQUlBLGlCQUFpQixHQUFHLEVBQXhCO0FBRUEsTUFBTUMsd0JBQXdCLEdBQUcsS0FBakM7O0FBQ0EsTUFBTUMsMEJBQTBCLEdBQUcsRUFBbkM7QUFFQSxNQUFNQyxxQkFBcUIsR0FBRyxzQkFBOUI7QUFDQSxNQUFNQywyQkFBMkIsR0FBRyxJQUFJQyxNQUFKLENBQVcsZ0NBQVgsRUFBNkMsR0FBN0MsQ0FBcEM7QUFDQSxNQUFNQyw2QkFBNkIsR0FBRyxJQUFJRCxNQUFKLENBQVksaUNBQVosRUFBOEMsR0FBOUMsQ0FBdEM7QUFDQSxNQUFNRSw4QkFBOEIsR0FBRyxJQUFJRixNQUFKLENBQVcsZ0NBQVgsRUFBNkMsR0FBN0MsQ0FBdkM7QUFFQSxNQUFNRyxVQUFVLEdBQUcsOEJBQW5CO0FBUUFSLGlCQUFpQixDQUFDUyxnQkFBbEIsR0FBcUNDLGdCQUFFQyxPQUFGLENBQVUsZ0JBQWdCQyxVQUFoQixFQUE0QjtBQUN6RUMsa0JBQUlDLElBQUosQ0FBVSxvQkFBbUJGLFVBQVcsYUFBeEM7O0FBQ0EsTUFBSSxLQUFLRyxPQUFULEVBQWtCO0FBQ2hCLFdBQU8sTUFBTSxLQUFLQyxvQkFBTCxDQUEwQkosVUFBMUIsQ0FBYjtBQUNEOztBQUNEQyxrQkFBSUksSUFBSixDQUFVLHNFQUFELEdBQ0Msa0VBREQsR0FFQyx5Q0FBd0NMLFVBQVcsR0FGN0Q7O0FBR0EsU0FBTyxNQUFNLEtBQUtNLGlCQUFMLENBQXVCTixVQUF2QixDQUFiO0FBQ0QsQ0FUb0MsQ0FBckM7QUFrQkFaLGlCQUFpQixDQUFDbUIsZUFBbEIsR0FBb0NULGdCQUFFQyxPQUFGLENBQVUsWUFBWTtBQUN4RCxTQUFPUyxzQkFBT0MsU0FBUCxLQUFxQixP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QmV6RSxpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgc3lzdGVtLCBmcywgdXRpbCwgdGVtcERpciB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB7IGdldFNka1Rvb2xzVmVyc2lvbiwgZ2V0QnVpbGRUb29sc0RpcnMsIGdldE9wZW5Tc2xGb3JPcyB9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgZXhlYywgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBzbGVlcCwgcmV0cnksIHJldHJ5SW50ZXJ2YWwsIHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgcXVvdGUgfSBmcm9tICdzaGVsbC1xdW90ZSc7XG5cblxubGV0IHN5c3RlbUNhbGxNZXRob2RzID0ge307XG5cbmNvbnN0IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVCA9IDIwMDAwOyAvLyBpbiBtaWxsaXNlY29uZHNcbmNvbnN0IERFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTID0gOTA7XG5cbmNvbnN0IExJTktFUl9XQVJOSU5HX1JFR0VYUCA9IC9eV0FSTklORzogbGlua2VyLiskL207XG5jb25zdCBQUk9UT0NPTF9GQVVMVF9FUlJPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKCdwcm90b2NvbCBmYXVsdCBcXFxcKG5vIHN0YXR1c1xcXFwpJywgJ2knKTtcbmNvbnN0IERFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cChgZXJyb3I6IGRldmljZSAoJy4rJyApP25vdCBmb3VuZGAsICdpJyk7XG5jb25zdCBERVZJQ0VfQ09OTkVDVElOR19FUlJPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKCdlcnJvcjogZGV2aWNlIHN0aWxsIGNvbm5lY3RpbmcnLCAnaScpO1xuXG5jb25zdCBDRVJUU19ST09UID0gJy9zeXN0ZW0vZXRjL3NlY3VyaXR5L2NhY2VydHMnO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGJpbmFyeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBiaW5hcnkgaW5jbHVkaW5nIGN1cnJlbnQgU0RLIHJvb3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFNka0JpbmFyeVBhdGggPSBfLm1lbW9pemUoYXN5bmMgZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgbG9nLmluZm8oYENoZWNraW5nIHdoZXRoZXIgJHtiaW5hcnlOYW1lfSBpcyBwcmVzZW50YCk7XG4gIGlmICh0aGlzLnNka1Jvb3QpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCaW5hcnlGcm9tU2RrUm9vdChiaW5hcnlOYW1lKTtcbiAgfVxuICBsb2cud2FybihgVGhlIEFORFJPSURfSE9NRSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0IHRvIHRoZSBBbmRyb2lkIFNESyBgICtcbiAgICAgICAgICAgYHJvb3QgZGlyZWN0b3J5IHBhdGguIEFORFJPSURfSE9NRSBpcyByZXF1aXJlZCBmb3IgY29tcGF0aWJpbGl0eSBgICtcbiAgICAgICAgICAgYHdpdGggU0RLIDIzKy4gQ2hlY2tpbmcgYWxvbmcgUEFUSCBmb3IgJHtiaW5hcnlOYW1lfS5gKTtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmluYXJ5RnJvbVBhdGgoYmluYXJ5TmFtZSk7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbmFtZSBvZiB0aGUgdG9vbCxcbiAqIHdoaWNoIHByaW50cyBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGNvbW1hbmQgc2hvcnRjdXQuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBEZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgcGxhdGZvcm0gdGhpcyBpc1xuICogICAgICAgICAgICAgICAgICBzdXBwb3NlZCB0byBiZSBlaXRoZXIgJ3doaWNoJyBvciAnd2hlcmUnLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRDb21tYW5kRm9yT1MgPSBfLm1lbW9pemUoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gc3lzdGVtLmlzV2luZG93cygpID8gJ3doZXJlJyA6ICd3aGljaCc7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIGJpbmFyeSBuYW1lIGZvciB0aGUgY3VycmVudCBvcGVyYXRpbmcgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gc2ltcGxlIGJpbmFyeSBuYW1lLCBmb3IgZXhhbXBsZSAnYW5kcm9pZCcuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZvcm1hdHRlZCBiaW5hcnkgbmFtZSBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgcGxhdGZvcm0sXG4gKiAgICAgICAgICAgICAgICAgIGZvciBleGFtcGxlLCAnYW5kcm9pZC5iYXQnIG9uIFdpbmRvd3MuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeU5hbWVGb3JPUyA9IF8ubWVtb2l6ZShmdW5jdGlvbiAoYmluYXJ5TmFtZSkge1xuICBpZiAoIXN5c3RlbS5pc1dpbmRvd3MoKSkge1xuICAgIHJldHVybiBiaW5hcnlOYW1lO1xuICB9XG5cbiAgaWYgKFsnYW5kcm9pZCcsICdhcGtzaWduZXInLCAnYXBrYW5hbHl6ZXInXS5pbmRleE9mKGJpbmFyeU5hbWUpID49IDAgJiZcbiAgICAgICFiaW5hcnlOYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5iYXQnKSkge1xuICAgIHJldHVybiBgJHtiaW5hcnlOYW1lfS5iYXRgO1xuICB9XG4gIGlmICghYmluYXJ5TmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuZXhlJykpIHtcbiAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uZXhlYDtcbiAgfVxuICByZXR1cm4gYmluYXJ5TmFtZTtcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gU2ltcGxlIG5hbWUgb2YgYSBiaW5hcnkgZmlsZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBiaW5hcnkuIFRoZSBtZXRob2QgdHJpZXNcbiAqICAgICAgICAgICAgICAgICAgdG8gZW51bWVyYXRlIGFsbCB0aGUga25vd24gbG9jYXRpb25zIHdoZXJlIHRoZSBiaW5hcnlcbiAqICAgICAgICAgICAgICAgICAgbWlnaHQgYmUgbG9jYXRlZCBhbmQgc3RvcHMgdGhlIHNlYXJjaCBhcyBzb29uIGFzIHRoZSBmaXJzdFxuICogICAgICAgICAgICAgICAgICBtYXRjaCBpcyBmb3VuZCBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGJpbmFyeSB3aXRoIGdpdmVuIG5hbWUgaXMgbm90IHByZXNlbnQgYXQgYW55XG4gKiAgICAgICAgICAgICAgICAgb2Yga25vd24gbG9jYXRpb25zIG9yIEFuZHJvaWQgU0RLIGlzIG5vdCBpbnN0YWxsZWQgb24gdGhlXG4gKiAgICAgICAgICAgICAgICAgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeUZyb21TZGtSb290ID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIChiaW5hcnlOYW1lKSB7XG4gIGxldCBiaW5hcnlMb2MgPSBudWxsO1xuICBiaW5hcnlOYW1lID0gdGhpcy5nZXRCaW5hcnlOYW1lRm9yT1MoYmluYXJ5TmFtZSk7XG4gIGxldCBiaW5hcnlMb2NzID0gW1xuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsICdwbGF0Zm9ybS10b29scycsIGJpbmFyeU5hbWUpLFxuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsICdlbXVsYXRvcicsIGJpbmFyeU5hbWUpLFxuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsICd0b29scycsIGJpbmFyeU5hbWUpLFxuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsICd0b29scycsICdiaW4nLCBiaW5hcnlOYW1lKVxuICBdO1xuICAvLyBnZXQgc3VicGF0aHMgZm9yIGN1cnJlbnRseSBpbnN0YWxsZWQgYnVpbGQgdG9vbCBkaXJlY3Rvcmllc1xuICBfLmZvckVhY2goYXdhaXQgZ2V0QnVpbGRUb29sc0RpcnModGhpcy5zZGtSb290KSxcbiAgICAgICAgICAgIChkaXIpID0+IGJpbmFyeUxvY3MucHVzaChwYXRoLnJlc29sdmUoZGlyLCBiaW5hcnlOYW1lKSkpO1xuICBmb3IgKGxldCBsb2Mgb2YgYmluYXJ5TG9jcykge1xuICAgIGlmIChhd2FpdCBmcy5leGlzdHMobG9jKSkge1xuICAgICAgYmluYXJ5TG9jID0gbG9jO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChfLmlzTnVsbChiaW5hcnlMb2MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAke2JpbmFyeU5hbWV9IGluICR7YmluYXJ5TG9jc30uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgRG8geW91IGhhdmUgdGhlIEFuZHJvaWQgU0RLIGluc3RhbGxlZCBhdCAnJHt0aGlzLnNka1Jvb3R9Jz9gKTtcbiAgfVxuICBiaW5hcnlMb2MgPSBiaW5hcnlMb2MudHJpbSgpO1xuICBsb2cuaW5mbyhgVXNpbmcgJHtiaW5hcnlOYW1lfSBmcm9tICR7YmluYXJ5TG9jfWApO1xuICByZXR1cm4gYmluYXJ5TG9jO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBwYXRoIHRvIGEgYmluYXJ5IGZpbGUgdXNpbmcgdGhlIHN0YW5kYXJkIHN5c3RlbSBsb29rdXAgdG9vbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgYmluYXJ5IHJlY2VpdmVkIGZyb20gJ3doaWNoJy8nd2hlcmUnXG4gKiAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBsb29rdXAgdG9vbCByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlGcm9tUGF0aCA9IGFzeW5jIGZ1bmN0aW9uIChiaW5hcnlOYW1lKSB7XG4gIGxldCBiaW5hcnlMb2MgPSBudWxsO1xuICBsZXQgY21kID0gdGhpcy5nZXRDb21tYW5kRm9yT1MoKTtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKGNtZCwgW2JpbmFyeU5hbWVdKTtcbiAgICBsb2cuaW5mbyhgVXNpbmcgJHtiaW5hcnlOYW1lfSBmcm9tICR7c3Rkb3V0fWApO1xuICAgIC8vIFRPRE8gd3JpdGUgYSB0ZXN0IGZvciBiaW5hcmllcyB3aXRoIHNwYWNlcy5cbiAgICBiaW5hcnlMb2MgPSBzdGRvdXQudHJpbSgpO1xuICAgIHJldHVybiBiaW5hcnlMb2M7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7YmluYXJ5TmFtZX0gUGxlYXNlIHNldCB0aGUgQU5EUk9JRF9IT01FIGAgK1xuICAgICAgICAgICAgICBgZW52aXJvbm1lbnQgdmFyaWFibGUgd2l0aCB0aGUgQW5kcm9pZCBTREsgcm9vdCBkaXJlY3RvcnkgcGF0aC5gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZXZpY2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1ZGlkIC0gVGhlIGRldmljZSB1ZGlkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gQ3VycmVudCBkZXZpY2Ugc3RhdGUsIGFzIGl0IGlzIHZpc2libGUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hZGIgZGV2aWNlcyAtbF8gb3V0cHV0LlxuICovXG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgZGV2aWNlcyB2aXNpYmxlIHRvIGFkYi5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgZGV2aWNlcyBvciBhbiBlbXB0eSBsaXN0IGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgbm8gZGV2aWNlcyBhcmUgY29ubmVjdGVkLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsaXN0aW5nIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbm5lY3RlZERldmljZXMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZygnR2V0dGluZyBjb25uZWN0ZWQgZGV2aWNlcy4uLicpO1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoWydkZXZpY2VzJ10pKTtcbiAgICAvLyBleHBlY3RpbmcgYWRiIGRldmljZXMgdG8gcmV0dXJuIG91dHB1dCBhc1xuICAgIC8vIExpc3Qgb2YgZGV2aWNlcyBhdHRhY2hlZFxuICAgIC8vIGVtdWxhdG9yLTU1NTRcdGRldmljZVxuICAgIGxldCBzdGFydGluZ0luZGV4ID0gc3Rkb3V0LmluZGV4T2YoJ0xpc3Qgb2YgZGV2aWNlcycpO1xuICAgIGlmIChzdGFydGluZ0luZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG91dHB1dCB3aGlsZSB0cnlpbmcgdG8gZ2V0IGRldmljZXMuIG91dHB1dCB3YXM6ICR7c3Rkb3V0fWApO1xuICAgIH1cbiAgICAvLyBzbGljaW5nIG91cHV0IHdlIGNhcmUgYWJvdXQuXG4gICAgc3Rkb3V0ID0gc3Rkb3V0LnNsaWNlKHN0YXJ0aW5nSW5kZXgpO1xuICAgIGxldCBkZXZpY2VzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzdGRvdXQuc3BsaXQoJ1xcbicpKSB7XG4gICAgICBpZiAobGluZS50cmltKCkgIT09ICcnICYmXG4gICAgICAgICAgbGluZS5pbmRleE9mKCdMaXN0IG9mIGRldmljZXMnKSA9PT0gLTEgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoJ2FkYiBzZXJ2ZXInKSA9PT0gLTEgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoJyogZGFlbW9uJykgPT09IC0xICYmXG4gICAgICAgICAgbGluZS5pbmRleE9mKCdvZmZsaW5lJykgPT09IC0xKSB7XG4gICAgICAgIGxldCBsaW5lSW5mbyA9IGxpbmUuc3BsaXQoJ1xcdCcpO1xuICAgICAgICAvLyBzdGF0ZSBpcyBlaXRoZXIgXCJkZXZpY2VcIiBvciBcIm9mZmxpbmVcIiwgYWZhaWN0XG4gICAgICAgIGRldmljZXMucHVzaCh7dWRpZDogbGluZUluZm9bMF0sIHN0YXRlOiBsaW5lSW5mb1sxXX0pO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYCR7ZGV2aWNlcy5sZW5ndGh9IGRldmljZShzKSBjb25uZWN0ZWRgKTtcbiAgICByZXR1cm4gZGV2aWNlcztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3Igd2hpbGUgZ2V0dGluZyBjb25uZWN0ZWQgZGV2aWNlcy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGRldmljZXMgdmlzaWJsZSB0byBhZGIgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGdldCBhdCBsZWFzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZSBsaXN0IGl0ZW0uXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgY29ubmVjdGVkIGRldmljZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbm8gY29ubmVjdGVkIGRldmljZXMgY2FuIGJlIGRldGVjdGVkIHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0RGV2aWNlc1dpdGhSZXRyeSA9IGFzeW5jIGZ1bmN0aW9uICh0aW1lb3V0TXMgPSAyMDAwMCkge1xuICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICBsb2cuZGVidWcoJ1RyeWluZyB0byBmaW5kIGEgY29ubmVjdGVkIGFuZHJvaWQgZGV2aWNlJyk7XG4gIGxldCBnZXREZXZpY2VzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICgoRGF0ZS5ub3coKSAtIHN0YXJ0KSA+IHRpbWVvdXRNcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhIGNvbm5lY3RlZCBBbmRyb2lkIGRldmljZS4nKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICBpZiAoZGV2aWNlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIGxvZy5kZWJ1ZygnQ291bGQgbm90IGZpbmQgZGV2aWNlcywgcmVzdGFydGluZyBhZGIgc2VydmVyLi4uJyk7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgICAvLyBjb29sIGRvd25cbiAgICAgICAgYXdhaXQgc2xlZXAoMjAwKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldERldmljZXMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy5kZWJ1ZygnQ291bGQgbm90IGZpbmQgZGV2aWNlcywgcmVzdGFydGluZyBhZGIgc2VydmVyLi4uJyk7XG4gICAgICBhd2FpdCB0aGlzLnJlc3RhcnRBZGIoKTtcbiAgICAgIC8vIGNvb2wgZG93blxuICAgICAgYXdhaXQgc2xlZXAoMjAwKTtcbiAgICAgIHJldHVybiBhd2FpdCBnZXREZXZpY2VzKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xufTtcblxuLyoqXG4gKiBSZXN0YXJ0IGFkYiBzZXJ2ZXIsIHVubGVzcyBfdGhpcy5zdXBwcmVzc0tpbGxTZXJ2ZXJfIHByb3BlcnR5IGlzIHRydWUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlc3RhcnRBZGIgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1cHByZXNzS2lsbFNlcnZlcikge1xuICAgIGxvZy5kZWJ1ZyhgTm90IHJlc3RhcnRpbmcgYWJkIHNpbmNlICdzdXBwcmVzc0tpbGxTZXJ2ZXInIGlzIG9uYCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbG9nLmRlYnVnKCdSZXN0YXJ0aW5nIGFkYicpO1xuICB0cnkge1xuICAgIGF3YWl0IHRoaXMua2lsbFNlcnZlcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yKFwiRXJyb3Iga2lsbGluZyBBREIgc2VydmVyLCBnb2luZyB0byBzZWUgaWYgaXQncyBvbmxpbmUgYW55d2F5XCIpO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgYWRiIHNlcnZlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbFNlcnZlciA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKGBLaWxsaW5nIGFkYiBzZXJ2ZXIgb24gcG9ydCAke3RoaXMuYWRiUG9ydH1gKTtcbiAgYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWy4uLnRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncywgJ2tpbGwtc2VydmVyJ10pO1xufTtcblxuLyoqXG4gKiBSZXNldCBUZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW4uXG4gKiBAc2VlIHtAbGluayBodHRwOi8vdG9vbHMuYW5kcm9pZC5jb20vcmVjZW50L2VtdWxhdG9yMjUxNnJlbGVhc2Vub3Rlc30gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdG9rZW4gcmVzZXQgd2FzIHN1Y2Nlc3NmdWwuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlc2V0VGVsbmV0QXV0aFRva2VuID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhlIG1ldGhvZHMgaXMgdXNlZCB0byByZW1vdmUgdGVsbmV0IGF1dGggdG9rZW5cbiAgLy9cbiAgY29uc3QgaG9tZUZvbGRlclBhdGggPSBwcm9jZXNzLmVudlsocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykgPyAnVVNFUlBST0ZJTEUnIDogJ0hPTUUnXTtcbiAgaWYgKCFob21lRm9sZGVyUGF0aCkge1xuICAgIGxvZy53YXJuKGBDYW5ub3QgZmluZCB0aGUgcGF0aCB0byB1c2VyIGhvbWUgZm9sZGVyLiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3IncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShob21lRm9sZGVyUGF0aCwgJy5lbXVsYXRvcl9jb25zb2xlX2F1dGhfdG9rZW4nKTtcbiAgbG9nLmRlYnVnKGBPdmVycmlkaW5nICR7ZHN0UGF0aH0gd2l0aCBhbiBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIGZvciBlbXVsYXRvciBjb21tYW5kc2ApO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cud2FybihgRXJyb3IgJHtlLm1lc3NhZ2V9IHdoaWxlIHJlc2V0dGluZyB0aGUgY29udGVudCBvZiAke2RzdFBhdGh9LiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3IncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBlbXVsYXRvciBjb21tYW5kIHVzaW5nIF9hZGIgZW11XyB0b29sLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNtZCAtIFRoZSBhcnJheSBvZiByZXN0IGNvbW1hbmQgbGluZSBwYXJhbWV0ZXJzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5hZGJFeGVjRW11ID0gYXN5bmMgZnVuY3Rpb24gKGNtZCkge1xuICBhd2FpdCB0aGlzLnZlcmlmeUVtdWxhdG9yQ29ubmVjdGVkKCk7XG4gIGF3YWl0IHRoaXMucmVzZXRUZWxuZXRBdXRoVG9rZW4oKTtcbiAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZW11JywgLi4uY21kXSk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdpdmVuIGFkYiBjb21tYW5kLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNtZCAtIFRoZSBhcnJheSBvZiByZXN0IGNvbW1hbmQgbGluZSBwYXJhbWV0ZXJzXG4gKiAgICAgICAgICAgICAgICAgICAgICBvciBhIHNpbmdsZSBzdHJpbmcgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgbWFwcGluZy4gU2VlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL25vZGUtdGVlbl9wcm9jZXNzfVxuICogICAgICAgICAgICAgICAgICAgICAgICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybiB7c3RyaW5nfSAtIENvbW1hbmQncyBzdGRvdXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvbW1hbmQgcmV0dXJuZWQgbm9uLXplcm8gZXhpdCBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5hZGJFeGVjID0gYXN5bmMgZnVuY3Rpb24gKGNtZCwgb3B0cyA9IHt9KSB7XG4gIGlmICghY21kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwYXNzIGluIGEgY29tbWFuZCB0byBhZGJFeGVjKCknKTtcbiAgfVxuXG4gIC8vIHNldHRpbmcgZGVmYXVsdCB0aW1lb3V0IGZvciBlYWNoIGNvbW1hbmQgdG8gcHJldmVudCBpbmZpbml0ZSB3YWl0LlxuICBvcHRzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwgdGhpcy5hZGJFeGVjVGltZW91dCB8fCBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQ7XG5cbiAgY21kID0gXy5pc0FycmF5KGNtZCkgPyBjbWQgOiBbY21kXTtcblxuICBsZXQgYWRiUmV0cmllZCA9IGZhbHNlO1xuICBjb25zdCBleGVjRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoY21kKTtcbiAgICAgIGxvZy5kZWJ1ZyhgUnVubmluZyAnJHt0aGlzLmV4ZWN1dGFibGUucGF0aH0gJHtxdW90ZShhcmdzKX0nYCk7XG4gICAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBhcmdzLCBvcHRzKTtcbiAgICAgIC8vIHNvbWV0aW1lcyBBREIgcHJpbnRzIG91dCB3ZWlyZCBzdGRvdXQgd2FybmluZ3MgdGhhdCB3ZSBkb24ndCB3YW50XG4gICAgICAvLyB0byBpbmNsdWRlIGluIGFueSBvZiB0aGUgcmVzcG9uc2UgZGF0YSwgc28gbGV0J3Mgc3RyaXAgaXQgb3V0XG4gICAgICBzdGRvdXQgPSBzdGRvdXQucmVwbGFjZShMSU5LRVJfV0FSTklOR19SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICByZXR1cm4gc3Rkb3V0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IGVyclRleHQgPSBgJHtlLm1lc3NhZ2V9LCAke2Uuc3Rkb3V0fSwgJHtlLnN0ZGVycn1gO1xuICAgICAgY29uc3QgcHJvdG9jb2xGYXVsdEVycm9yID0gUFJPVE9DT0xfRkFVTFRfRVJST1JfUkVHRVhQLnRlc3QoZXJyVGV4dCk7XG4gICAgICBjb25zdCBkZXZpY2VOb3RGb3VuZEVycm9yID0gREVWSUNFX05PVF9GT1VORF9FUlJPUl9SRUdFWFAudGVzdChlcnJUZXh0KTtcbiAgICAgIGNvbnN0IGRldmljZUNvbm5lY3RpbmdFcnJvciA9IERFVklDRV9DT05ORUNUSU5HX0VSUk9SX1JFR0VYUC50ZXN0KGVyclRleHQpO1xuICAgICAgaWYgKHByb3RvY29sRmF1bHRFcnJvciB8fCBkZXZpY2VOb3RGb3VuZEVycm9yIHx8IGRldmljZUNvbm5lY3RpbmdFcnJvcikge1xuICAgICAgICBsb2cuaW5mbyhgRXJyb3Igc2VuZGluZyBjb21tYW5kLCByZWNvbm5lY3RpbmcgZGV2aWNlIGFuZCByZXRyeWluZzogJHtjbWR9YCk7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMDApO1xuICAgICAgICBhd2FpdCB0aGlzLmdldERldmljZXNXaXRoUmV0cnkoKTtcblxuICAgICAgICAvLyB0cnkgYWdhaW4gb25lIHRpbWVcbiAgICAgICAgaWYgKGFkYlJldHJpZWQpIHtcbiAgICAgICAgICBhZGJSZXRyaWVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZXhlY0Z1bmMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZS5jb2RlID09PSAwICYmIGUuc3Rkb3V0KSB7XG4gICAgICAgIHJldHVybiBlLnN0ZG91dC5yZXBsYWNlKExJTktFUl9XQVJOSU5HX1JFR0VYUCwgJycpLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNOdWxsKGUuY29kZSkpIHtcbiAgICAgICAgZS5tZXNzYWdlID0gYEVycm9yIGV4ZWN1dGluZyBhZGJFeGVjLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfScuIGAgK1xuICAgICAgICAgIGBUcnkgdG8gaW5jcmVhc2UgdGhlICR7b3B0cy50aW1lb3V0fW1zIGFkYiBleGVjdXRpb24gdGltZW91dCByZXByZXNlbnRlZCBieSAnYWRiRXhlY1RpbWVvdXQnIGNhcGFiaWxpdHlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5tZXNzYWdlID0gYEVycm9yIGV4ZWN1dGluZyBhZGJFeGVjLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYDtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBhd2FpdCBleGVjRnVuYygpO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaGVsbEV4ZWNPcHRpb25zXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBwcml2aWxlZ2VkIFtmYWxzeV0gLSBXaGV0aGVyIHRvIHJ1biB0aGUgZ2l2ZW4gY29tbWFuZCBhcyByb290LlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0ga2VlcFByaXZpbGVnZWQgW2ZhbHN5XSAtIFdoZXRoZXIgdG8ga2VlcCByb290IG1vZGUgYWZ0ZXIgY29tbWFuZCBleGVjdXRpb24gaXMgY29tcGxldGVkLlxuICpcbiAqIEFsbCBvdGhlciBwcm9wZXJ0aWVzIGFyZSB0aGUgc2FtZSBhcyBmb3IgYGV4ZWNgIGNhbGwgZnJvbSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqIG1vZHVsZVxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gY29tbWFuZCB1c2luZyBfYWRiIHNoZWxsXyBwcmVmaXguXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz58c3RyaW5nfSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVycyBvciBhIHNpbmdsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0gez9TaGVsbEV4ZWNPcHRpb25zfSBvcHRzIFt7fV0gLSBBZGRpdGlvbmFsIG9wdGlvbnMgbWFwcGluZy5cbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2hlbGwgPSBhc3luYyBmdW5jdGlvbiAoY21kLCBvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHByaXZpbGVnZWQsXG4gICAga2VlcFByaXZpbGVnZWQsXG4gIH0gPSBvcHRzO1xuICBsZXQgc2hvdWxkUmVzdG9yZVVzZXIgPSBmYWxzZTtcbiAgaWYgKHByaXZpbGVnZWQpIHtcbiAgICB0cnkge1xuICAgICAgc2hvdWxkUmVzdG9yZVVzZXIgPSAhKGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3Jvb3QnXSwgb3B0cykpLmluY2x1ZGVzKCdhbHJlYWR5IHJ1bm5pbmcgYXMgcm9vdCcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFlcnIubWVzc2FnZS5pbmNsdWRlcygnYWRiZCBjYW5ub3QgcnVuIGFzIHJvb3QnKSkge1xuICAgICAgICAvLyBEbyBub3Qgc2hvdyB0aGUgd2FybmluZyBmb3IgcmVhbCBkZXZpY2VzLCB3aGVyZSByb290IGlzIGxvY2tlZFxuICAgICAgICBsb2cud2FybihgQ2Fubm90IHJ1biBhZGJkIGFzIHJvb3QuIE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgZGlkQ29tbWFuZEZhaWwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRiRXhlYyhfLmlzQXJyYXkoY21kKSA/IFsnc2hlbGwnLCAuLi5jbWRdIDogWydzaGVsbCcsIGNtZF0sIG9wdHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZGlkQ29tbWFuZEZhaWwgPSB0cnVlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAocHJpdmlsZWdlZCAmJiBzaG91bGRSZXN0b3JlVXNlciAmJiAoIWtlZXBQcml2aWxlZ2VkIHx8IGRpZENvbW1hbmRGYWlsKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5hZGJFeGVjKFsndW5yb290J10sIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy53YXJuKGBDYW5ub3QgcnVuIGFkYmQgYXMgbm9uLXJvb3QuIE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuY3JlYXRlU3ViUHJvY2VzcyA9IGZ1bmN0aW9uIChhcmdzID0gW10pIHtcbiAgLy8gYWRkIHRoZSBkZWZhdWx0IGFyZ3VtZW50c1xuICBhcmdzID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmNvbmNhdChhcmdzKTtcbiAgbG9nLmRlYnVnKGBDcmVhdGluZyBBREIgc3VicHJvY2VzcyB3aXRoIGFyZ3M6ICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCk7XG4gIHJldHVybiBuZXcgU3ViUHJvY2Vzcyh0aGlzLmdldEFkYlBhdGgoKSwgYXJncyk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGFkYiBwb3J0LlxuICogQHRvZG8gY2FuIHByb2JhYmx5IGRlcHJlY2F0ZSB0aGlzIG5vdyB0aGF0IHRoZSBsb2dpYyBpcyBqdXN0IHRvIHJlYWQgdGhpcy5hZGJQb3J0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IGFkYiBwb3J0IG51bWJlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QWRiU2VydmVyUG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYWRiUG9ydDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydCBmcm9tIF9hZGIgZGV2aXZlc18gb3V0cHV0LlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBhcmUgbm8gY29ubmVjdGVkIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEVtdWxhdG9yUG9ydCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKCdHZXR0aW5nIHJ1bm5pbmcgZW11bGF0b3IgcG9ydCcpO1xuICBpZiAodGhpcy5lbXVsYXRvclBvcnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbXVsYXRvclBvcnQ7XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgIGxldCBwb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZXNbMF0udWRpZCk7XG4gICAgaWYgKHBvcnQpIHtcbiAgICAgIHJldHVybiBwb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIHBvcnQgbm90IGZvdW5kYCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXZpY2VzIGNvbm5lY3RlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgYnkgcGFyc2luZyBlbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW1TdHIgLSBFbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSBFaXRoZXIgdGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIF9mYWxzZV8gaWYgcG9ydCBudW1iZXIgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyA9IGZ1bmN0aW9uIChlbVN0cikge1xuICBsZXQgcG9ydFBhdHRlcm4gPSAvZW11bGF0b3ItKFxcZCspLztcbiAgaWYgKHBvcnRQYXR0ZXJuLnRlc3QoZW1TdHIpKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHBvcnRQYXR0ZXJuLmV4ZWMoZW1TdHIpWzFdLCAxMCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBjdXJyZW50bHkgY29ubmVjdGVkIGVtdWxhdG9ycy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgY29ubmVjdGVkIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbm5lY3RlZEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKCdHZXR0aW5nIGNvbm5lY3RlZCBlbXVsYXRvcnMnKTtcbiAgdHJ5IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgIGxldCBlbXVsYXRvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBkZXZpY2Ugb2YgZGV2aWNlcykge1xuICAgICAgbGV0IHBvcnQgPSB0aGlzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcoZGV2aWNlLnVkaWQpO1xuICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgZGV2aWNlLnBvcnQgPSBwb3J0O1xuICAgICAgICBlbXVsYXRvcnMucHVzaChkZXZpY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYCR7ZW11bGF0b3JzLmxlbmd0aH0gZW11bGF0b3IocykgY29ubmVjdGVkYCk7XG4gICAgcmV0dXJuIGVtdWxhdG9ycztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBlbXVsYXRvcnMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgX2VtdWxhdG9yUG9ydF8gcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGVtUG9ydCAtIFRoZSBlbXVsYXRvciBwb3J0IHRvIGJlIHNldC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RW11bGF0b3JQb3J0ID0gZnVuY3Rpb24gKGVtUG9ydCkge1xuICB0aGlzLmVtdWxhdG9yUG9ydCA9IGVtUG9ydDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBpZGVudGlmaWVyIG9mIHRoZSBjdXJyZW50IGRldmljZSAoX3RoaXMuY3VyRGV2aWNlSWRfKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gLSBUaGUgZGV2aWNlIGlkZW50aWZpZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldERldmljZUlkID0gZnVuY3Rpb24gKGRldmljZUlkKSB7XG4gIGxvZy5kZWJ1ZyhgU2V0dGluZyBkZXZpY2UgaWQgdG8gJHtkZXZpY2VJZH1gKTtcbiAgdGhpcy5jdXJEZXZpY2VJZCA9IGRldmljZUlkO1xuICBsZXQgYXJnc0hhc0RldmljZSA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5pbmRleE9mKCctcycpO1xuICBpZiAoYXJnc0hhc0RldmljZSAhPT0gLTEpIHtcbiAgICAvLyByZW1vdmUgdGhlIG9sZCBkZXZpY2UgaWQgZnJvbSB0aGUgYXJndW1lbnRzXG4gICAgdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLnNwbGljZShhcmdzSGFzRGV2aWNlLCAyKTtcbiAgfVxuICB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MucHVzaCgnLXMnLCBkZXZpY2VJZCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdGhlIGN1cnJlbnQgZGV2aWNlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0RldmljZX0gZGV2aWNlT2JqIC0gVGhlIGRldmljZSBvYmplY3QgdG8gYmUgc2V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXREZXZpY2UgPSBmdW5jdGlvbiAoZGV2aWNlT2JqKSB7XG4gIGxldCBkZXZpY2VJZCA9IGRldmljZU9iai51ZGlkO1xuICBsZXQgZW1Qb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZUlkKTtcbiAgdGhpcy5zZXRFbXVsYXRvclBvcnQoZW1Qb3J0KTtcbiAgdGhpcy5zZXREZXZpY2VJZChkZXZpY2VJZCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBFbXVsYXRvciBuYW1lLlxuICogQHJldHVybiB7P0RldmljZX0gQ3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3Igb3IgX251bGxfLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRSdW5uaW5nQVZEID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUpIHtcbiAgbG9nLmRlYnVnKGBUcnlpbmcgdG8gZmluZCAke2F2ZE5hbWV9IGVtdWxhdG9yYCk7XG4gIHRyeSB7XG4gICAgbGV0IGVtdWxhdG9ycyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRW11bGF0b3JzKCk7XG4gICAgZm9yIChsZXQgZW11bGF0b3Igb2YgZW11bGF0b3JzKSB7XG4gICAgICB0aGlzLnNldEVtdWxhdG9yUG9ydChlbXVsYXRvci5wb3J0KTtcbiAgICAgIGxldCBydW5uaW5nQVZETmFtZSA9IGF3YWl0IHRoaXMuc2VuZFRlbG5ldENvbW1hbmQoJ2F2ZCBuYW1lJyk7XG4gICAgICBpZiAoYXZkTmFtZSA9PT0gcnVubmluZ0FWRE5hbWUpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBGb3VuZCBlbXVsYXRvciAke2F2ZE5hbWV9IGluIHBvcnQgJHtlbXVsYXRvci5wb3J0fWApO1xuICAgICAgICB0aGlzLnNldERldmljZUlkKGVtdWxhdG9yLnVkaWQpO1xuICAgICAgICByZXR1cm4gZW11bGF0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgRW11bGF0b3IgJHthdmROYW1lfSBub3QgcnVubmluZ2ApO1xuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIEFWRC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBFbXVsYXRvciBuYW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gd2FpdCB1bnRpbCBhdCBsZWFzdCBvbmUgcnVubmluZyBBVkQgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBkZXRlY3RlZC5cbiAqIEByZXR1cm4gez9EZXZpY2V9IEN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yIG9yIF9udWxsXy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBkZXZpY2UgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIHRoZSB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUsIHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIGxldCBydW5uaW5nQXZkO1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVubmluZ0F2ZCA9IGF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lLnJlcGxhY2UoJ0AnLCAnJykpO1xuICAgICAgICByZXR1cm4gcnVubmluZ0F2ZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nLmRlYnVnKGUubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB3YWl0TXM6IHRpbWVvdXRNcyxcbiAgICAgIGludGVydmFsTXM6IDEwMDAsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgQVZEIHdpdGggcmV0cnkuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxuICByZXR1cm4gcnVubmluZ0F2ZDtcbn07XG5cbi8qKlxuICogU2h1dGRvd24gYWxsIHJ1bm5pbmcgZW11bGF0b3JzIGJ5IGtpbGxpbmcgdGhlaXIgcHJvY2Vzc2VzLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBraWxsaW5nIHRvb2wgcmV0dXJuZWQgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxBbGxFbXVsYXRvcnMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBjbWQsIGFyZ3M7XG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBjbWQgPSAnVEFTS0tJTEwnO1xuICAgIGFyZ3MgPSBbJ1RBU0tLSUxMJywgJy9JTScsICdlbXVsYXRvci5leGUnXTtcbiAgfSBlbHNlIHtcbiAgICBjbWQgPSAnL3Vzci9iaW4va2lsbGFsbCc7XG4gICAgYXJncyA9IFsnLW0nLCAnZW11bGF0b3IqJ107XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKGNtZCwgYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGtpbGxpbmcgZW11bGF0b3JzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogS2lsbCBlbXVsYXRvciB3aXRoIHRoZSBnaXZlbiBuYW1lLiBObyBlcnJvclxuICogaXMgdGhyb3duIGlzIGdpdmVuIGF2ZCBkb2VzIG5vdCBleGlzdC9pcyBub3QgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZW11bGF0b3IgdG8gYmUga2lsbGVkLiBJZiBlbXB0eSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjdXJyZW50IGVtdWxhdG9yIHdpbGwgYmUga2lsbGVkLlxuICogQHBhcmFtIHs/bnVtYmVyfSB0aW1lb3V0IFs2MDAwMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgdGhyb3dpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gZXhjZXB0aW9uIGFib3V0IHVuc3VjY2Vzc2Z1bCBraWxsaW5nXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGVtdWxhdG9yIHdhcyBraWxsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGVyZSB3YXMgYSBmYWlsdXJlIGJ5IGtpbGxpbmcgdGhlIGVtdWxhdG9yXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxFbXVsYXRvciA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lID0gbnVsbCwgdGltZW91dCA9IDYwMDAwKSB7XG4gIGlmICh1dGlsLmhhc1ZhbHVlKGF2ZE5hbWUpKSB7XG4gICAgbG9nLmRlYnVnKGBLaWxsaW5nIGF2ZCAnJHthdmROYW1lfSdgKTtcbiAgICBjb25zdCBkZXZpY2UgPSBhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZSk7XG4gICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgIGxvZy5pbmZvKGBObyBhdmQgd2l0aCBuYW1lICcke2F2ZE5hbWV9JyBydW5uaW5nLiBTa2lwcGluZyBraWxsIHN0ZXAuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGtpbGxpbmcgdGhlIGN1cnJlbnQgYXZkXG4gICAgbG9nLmRlYnVnKGBLaWxsaW5nIGF2ZCB3aXRoIGlkICcke3RoaXMuY3VyRGV2aWNlSWR9J2ApO1xuICAgIGlmICghYXdhaXQgdGhpcy5pc0VtdWxhdG9yQ29ubmVjdGVkKCkpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgRW11bGF0b3Igd2l0aCBpZCAnJHt0aGlzLmN1ckRldmljZUlkfScgbm90IGNvbm5lY3RlZC4gU2tpcHBpbmcga2lsbCBzdGVwYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2VtdScsICdraWxsJ10pO1xuICBsb2cuZGVidWcoYFdhaXRpbmcgdXAgdG8gJHt0aW1lb3V0fW1zIHVudGlsIHRoZSBlbXVsYXRvciAnJHthdmROYW1lID8gYXZkTmFtZSA6IHRoaXMuY3VyRGV2aWNlSWR9JyBpcyBraWxsZWRgKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1dGlsLmhhc1ZhbHVlKGF2ZE5hbWUpXG4gICAgICAgICAgPyAhYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUpXG4gICAgICAgICAgOiAhYXdhaXQgdGhpcy5pc0VtdWxhdG9yQ29ubmVjdGVkKCk7XG4gICAgICB9IGNhdGNoIChpZ24pIHt9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0LFxuICAgICAgaW50ZXJ2YWxNczogMjAwMCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGVtdWxhdG9yICcke2F2ZE5hbWUgPyBhdmROYW1lIDogdGhpcy5jdXJEZXZpY2VJZH0nIGlzIHN0aWxsIHJ1bm5pbmcgYWZ0ZXIgYmVpbmcga2lsbGVkICR7dGltZW91dH1tcyBhZ29gKTtcbiAgfVxuICBsb2cuaW5mbyhgU3VjY2Vzc2Z1bGx5IGtpbGxlZCB0aGUgJyR7YXZkTmFtZSA/IGF2ZE5hbWUgOiB0aGlzLmN1ckRldmljZUlkfScgZW11bGF0b3JgKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFN0YXJ0IGFuIGVtdWxhdG9yIHdpdGggZ2l2ZW4gcGFyYW1ldGVycyBhbmQgd2FpdCB1bnRpbCBpdCBpcyBmdWxsIHN0YXJ0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiBhbiBleGlzdGluZyBlbXVsYXRvci5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSBhdmRBcmdzIC0gQWRkaXRpb25hbCBlbXVsYXRvciBjb21tYW5kIGxpbmUgYXJndW1lbnQuXG4gKiBAcGFyYW0gez9zdHJpbmd9IGxhbmd1YWdlIC0gRW11bGF0b3Igc3lzdGVtIGxhbmd1YWdlLlxuICogQHBhcmFtIHs/Y291bnRyeX0gY291bnRyeSAtIEVtdWxhdG9yIHN5c3RlbSBjb3VudHJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IGF2ZExhdW5jaFRpbWVvdXQgWzYwMDAwXSAtIEVtdWxhdG9yIHN0YXJ0dXAgdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cnlUaW1lcyBbMV0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc3RhcnR1cCByZXRyaWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciBmYWlscyB0byBzdGFydCB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmxhdW5jaEFWRCA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lLCBhdmRBcmdzLCBsYW5ndWFnZSwgY291bnRyeSxcbiAgYXZkTGF1bmNoVGltZW91dCA9IDYwMDAwLCBhdmRSZWFkeVRpbWVvdXQgPSA2MDAwMCwgcmV0cnlUaW1lcyA9IDEpIHtcbiAgbG9nLmRlYnVnKGBMYXVuY2hpbmcgRW11bGF0b3Igd2l0aCBBVkQgJHthdmROYW1lfSwgbGF1bmNoVGltZW91dCBgICtcbiAgICAgICAgICAgIGAke2F2ZExhdW5jaFRpbWVvdXR9bXMgYW5kIHJlYWR5VGltZW91dCAke2F2ZFJlYWR5VGltZW91dH1tc2ApO1xuICBsZXQgZW11bGF0b3JCaW5hcnlQYXRoID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKCdlbXVsYXRvcicpO1xuICBpZiAoYXZkTmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgYXZkTmFtZSA9IGF2ZE5hbWUuc3Vic3RyKDEpO1xuICB9XG4gIGF3YWl0IHRoaXMuY2hlY2tBdmRFeGlzdChhdmROYW1lKTtcbiAgbGV0IGxhdW5jaEFyZ3MgPSBbJy1hdmQnLCBhdmROYW1lXTtcbiAgaWYgKF8uaXNTdHJpbmcobGFuZ3VhZ2UpKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIEFuZHJvaWQgRGV2aWNlIExhbmd1YWdlIHRvICR7bGFuZ3VhZ2V9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKCctcHJvcCcsIGBwZXJzaXN0LnN5cy5sYW5ndWFnZT0ke2xhbmd1YWdlLnRvTG93ZXJDYXNlKCl9YCk7XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcoY291bnRyeSkpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgQ291bnRyeSB0byAke2NvdW50cnl9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKCctcHJvcCcsIGBwZXJzaXN0LnN5cy5jb3VudHJ5PSR7Y291bnRyeS50b1VwcGVyQ2FzZSgpfWApO1xuICB9XG4gIGxldCBsb2NhbGU7XG4gIGlmIChfLmlzU3RyaW5nKGxhbmd1YWdlKSAmJiBfLmlzU3RyaW5nKGNvdW50cnkpKSB7XG4gICAgbG9jYWxlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSArICctJyArIGNvdW50cnkudG9VcHBlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGxhbmd1YWdlKSkge1xuICAgIGxvY2FsZSA9IGxhbmd1YWdlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhjb3VudHJ5KSkge1xuICAgIGxvY2FsZSA9IGNvdW50cnk7XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcobG9jYWxlKSkge1xuICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBBbmRyb2lkIERldmljZSBMb2NhbGUgdG8gJHtsb2NhbGV9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKCctcHJvcCcsIGBwZXJzaXN0LnN5cy5sb2NhbGU9JHtsb2NhbGV9YCk7XG4gIH1cbiAgaWYgKCFfLmlzRW1wdHkoYXZkQXJncykpIHtcbiAgICBsYXVuY2hBcmdzLnB1c2goLi4uKF8uaXNBcnJheShhdmRBcmdzKSA/IGF2ZEFyZ3MgOiBhdmRBcmdzLnNwbGl0KCcgJykpKTtcbiAgfVxuICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7ZW11bGF0b3JCaW5hcnlQYXRofScgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGxhdW5jaEFyZ3MpfWApO1xuICBsZXQgcHJvYyA9IG5ldyBTdWJQcm9jZXNzKGVtdWxhdG9yQmluYXJ5UGF0aCwgbGF1bmNoQXJncyk7XG4gIGF3YWl0IHByb2Muc3RhcnQoMCk7XG4gIHByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2YgKHN0ZG91dCB8fCBzdGRlcnIgfHwgJycpLnNwbGl0KCdcXG4nKS5maWx0ZXIoQm9vbGVhbikpIHtcbiAgICAgIGxvZy5pbmZvKGBbQVZEIE9VVFBVVF0gJHtsaW5lfWApO1xuICAgIH1cbiAgfSk7XG4gIHByb2Mub24oJ2RpZScsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICBsb2cud2FybihgRW11bGF0b3IgYXZkICR7YXZkTmFtZX0gZXhpdGVkIHdpdGggY29kZSAke2NvZGV9JHtzaWduYWwgPyBgLCBzaWduYWwgJHtzaWduYWx9YCA6ICcnfWApO1xuICB9KTtcbiAgYXdhaXQgcmV0cnkocmV0cnlUaW1lcywgYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5KGF2ZE5hbWUsIGF2ZExhdW5jaFRpbWVvdXQpKTtcbiAgYXdhaXQgdGhpcy53YWl0Rm9yRW11bGF0b3JSZWFkeShhdmRSZWFkeVRpbWVvdXQpO1xuICByZXR1cm4gcHJvYztcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQURCVmVyc2lvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZlcnNpb25TdHJpbmcgLSBBREIgdmVyc2lvbiBhcyBhIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IHZlcnNpb25GbG9hdCAtIFZlcnNpb24gbnVtYmVyIGFzIGZsb2F0IHZhbHVlICh1c2VmdWwgZm9yIGNvbXBhcmlzb24pLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1ham9yIC0gTWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWlub3IgLSBNaW5vciB2ZXJzaW9uIG51bWJlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXRjaCAtIFBhdGNoIHZlcnNpb24gbnVtYmVyLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSBhZGIgdmVyc2lvbi4gVGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBjYWNoZWQuXG4gKlxuICogQHJldHVybiB7QURCVmVyc2lvbn0gVGhlIGN1cnJlbnQgYWRiIHZlcnNpb24uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHBhcnNlIGFkYiB2ZXJzaW9uLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRBZGJWZXJzaW9uID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBsZXQgYWRiVmVyc2lvbiA9IChhd2FpdCB0aGlzLmFkYkV4ZWMoJ3ZlcnNpb24nKSlcbiAgICAgIC5yZXBsYWNlKC9BbmRyb2lkXFxzRGVidWdcXHNCcmlkZ2VcXHN2ZXJzaW9uXFxzKFtcXGQuXSopW1xcc1xcdy1dKi8sICckMScpO1xuICAgIGxldCBwYXJ0cyA9IGFkYlZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvblN0cmluZzogYWRiVmVyc2lvbixcbiAgICAgIHZlcnNpb25GbG9hdDogcGFyc2VGbG9hdChhZGJWZXJzaW9uKSxcbiAgICAgIG1ham9yOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgbWlub3I6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgICBwYXRjaDogcGFydHNbMl0gPyBwYXJzZUludChwYXJ0c1syXSwgMTApIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgYWRiIHZlcnNpb24uIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2ApO1xuICB9XG59KTtcblxuLyoqXG4gKiBDaGVjayBpZiBnaXZlbiBlbXVsYXRvciBleGlzdHMgaW4gdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGF2ZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiBlbXVsYXRvciB0byB2ZXJpZnkgZm9yIGV4aXN0ZW5jZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZW11bGF0b3Igd2l0aCBnaXZlbiBuYW1lIGRvZXMgbm90IGV4aXN0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5jaGVja0F2ZEV4aXN0ID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUpIHtcbiAgbGV0IGNtZCwgcmVzdWx0O1xuICB0cnkge1xuICAgIGNtZCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aCgnZW11bGF0b3InKTtcbiAgICByZXN1bHQgPSBhd2FpdCBleGVjKGNtZCwgWyctbGlzdC1hdmRzJ10pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbGV0IHVua25vd25PcHRpb25FcnJvciA9IG5ldyBSZWdFeHAoJ3Vua25vd24gb3B0aW9uOiAtbGlzdC1hdmRzJywgJ2knKS50ZXN0KGUuc3RkZXJyKTtcbiAgICBpZiAoIXVua25vd25PcHRpb25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBleGVjdXRpbmcgY2hlY2tBdmRFeGlzdC4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2ApO1xuXG4gICAgfVxuICAgIGNvbnN0IHNka1ZlcnNpb24gPSBhd2FpdCBnZXRTZGtUb29sc1ZlcnNpb24oKTtcbiAgICBsZXQgYmluYXJ5TmFtZSA9ICdhbmRyb2lkJztcbiAgICBpZiAoc2RrVmVyc2lvbikge1xuICAgICAgaWYgKHNka1ZlcnNpb24ubWFqb3IgPj0gMjUpIHtcbiAgICAgICAgYmluYXJ5TmFtZSA9ICdhdmRtYW5hZ2VyJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLndhcm4oYERlZmF1bHRpbmcgYmluYXJ5IG5hbWUgdG8gJyR7YmluYXJ5TmFtZX0nLCBiZWNhdXNlIFNESyB2ZXJzaW9uIGNhbm5vdCBiZSBwYXJzZWRgKTtcbiAgICB9XG4gICAgLy8gSWYgLWxpc3QtYXZkcyBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSwgdXNlIGFuZHJvaWQgY29tbWFuZCBhcyBhbiBhbHRlcm5hdGl2ZVxuICAgIGNtZCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aChiaW5hcnlOYW1lKTtcbiAgICByZXN1bHQgPSBhd2FpdCBleGVjKGNtZCwgWydsaXN0JywgJ2F2ZCcsICctYyddKTtcbiAgfVxuICBpZiAocmVzdWx0LnN0ZG91dC5pbmRleE9mKGF2ZE5hbWUpID09PSAtMSkge1xuICAgIGxldCBleGlzdGluZ3MgPSBgKCR7cmVzdWx0LnN0ZG91dC50cmltKCkucmVwbGFjZSgvW1xcbl0vZywgJyksICgnKX0pYDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEF2ZCAnJHthdmROYW1lfScgaXMgbm90IGF2YWlsYWJsZS4gcGxlYXNlIHNlbGVjdCB5b3VyIGF2ZCBuYW1lIGZyb20gb25lIG9mIHRoZXNlOiAnJHtleGlzdGluZ3N9J2ApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGVtdWxhdG9yIGlzIHJlYWR5IHRvIGFjY2VwdCBmdXJ0aGVyIGNvbW1hbmRzIChib290aW5nIGNvbXBsZXRlZCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciBpcyBub3QgcmVhZHkgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy53YWl0Rm9yRW11bGF0b3JSZWFkeSA9IGFzeW5jIGZ1bmN0aW9uICh0aW1lb3V0TXMgPSAyMDAwMCkge1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5zaGVsbChbJ2dldHByb3AnLCAnaW5pdC5zdmMuYm9vdGFuaW0nXSkpLmluY2x1ZGVzKCdzdG9wcGVkJykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZSBwYWNrYWdlIG1hbmFnZXIgc2VydmljZSBtaWdodCBzdGlsbCBiZWluZyBpbml0aWFsaXplZFxuICAgICAgICAvLyBvbiBzbG93IHN5c3RlbXMgZXZlbiBhZnRlciBlbXVsYXRvciBib290aW5nIGlzIGNvbXBsZXRlZC5cbiAgICAgICAgLy8gVGhlIHVzdWFsIG91dHB1dCBvZiBgcG0gZ2V0LWluc3RhbGwtbG9jYXRpb25gIGNvbW1hbmQgbG9va3MgbGlrZSBgMFthdXRvXWBcbiAgICAgICAgcmV0dXJuIC9cXGQrXFxbXFx3K1xcXS8udGVzdChhd2FpdCB0aGlzLnNoZWxsKFsncG0nLCAnZ2V0LWluc3RhbGwtbG9jYXRpb24nXSkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgV2FpdGluZyBmb3IgZW11bGF0b3Igc3RhcnR1cC4gSW50ZXJtZWRpYXRlIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0TXMsXG4gICAgICBpbnRlcnZhbE1zOiAzMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFbXVsYXRvciBpcyBub3QgcmVhZHkgd2l0aGluICR7dGltZW91dE1zfW1zYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZGV2aWNlIGlzIHJlYWR5IHRvIGFjY2VwdCBmdXJ0aGVyIGNvbW1hbmRzIChib290aW5nIGNvbXBsZXRlZCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFwcERldmljZVJlYWR5VGltZW91dCBbMzBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGV2aWNlIGlzIG5vdCByZWFkeSB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLndhaXRGb3JEZXZpY2UgPSBhc3luYyBmdW5jdGlvbiAoYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gMzApIHtcbiAgdGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQgPSBhcHBEZXZpY2VSZWFkeVRpbWVvdXQ7XG4gIGNvbnN0IHJldHJpZXMgPSAzO1xuICBjb25zdCB0aW1lb3V0ID0gcGFyc2VJbnQodGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQsIDEwKSAvIHJldHJpZXMgKiAxMDAwO1xuICBhd2FpdCByZXRyeShyZXRyaWVzLCBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYygnd2FpdC1mb3ItZGV2aWNlJywge3RpbWVvdXR9KTtcbiAgICAgIGF3YWl0IHRoaXMucGluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdhaXRpbmcgZm9yIHRoZSBkZXZpY2UgdG8gYmUgYXZhaWxhYmxlLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSdgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWJvb3QgdGhlIGN1cnJlbnQgZGV2aWNlIGFuZCB3YWl0IHVudGlsIGl0IGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cmllcyBbREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVNdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlYm9vdCByZXRyaWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgZmFpbGVkIHRvIHJlYm9vdCBhbmQgbnVtYmVyIG9mIHJldHJpZXMgaXMgZXhjZWVkZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlYm9vdCA9IGFzeW5jIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVMpIHtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0b3AnXSwge1xuICAgIHByaXZpbGVnZWQ6IHRydWUsXG4gIH0pO1xuICBhd2FpdCBCLmRlbGF5KDIwMDApOyAvLyBsZXQgdGhlIGVtdSBmaW5pc2ggc3RvcHBpbmc7XG4gIGF3YWl0IHRoaXMuc2V0RGV2aWNlUHJvcGVydHkoJ3N5cy5ib290X2NvbXBsZXRlZCcsIDApO1xuICBhd2FpdCB0aGlzLnNoZWxsKFsnc3RhcnQnXSwge1xuICAgIHByaXZpbGVnZWQ6IHRydWUsXG4gIH0pO1xuICBjb25zdCBzdGFydGVkID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgYXdhaXQgcmV0cnlJbnRlcnZhbChyZXRyaWVzLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKChhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnKSkgPT09ICcxJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBzdGFjayB0cmFjZSwgc28gbm8gbG9nLmVycm9yQW5kVGhyb3dcbiAgICBjb25zdCBtc2cgPSBgUmVib290IGlzIG5vdCBjb21wbGV0ZWQgYWZ0ZXIgJHtwcm9jZXNzLmhydGltZShzdGFydGVkKVswXX1zYDtcbiAgICBsb2cuZGVidWcobXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN3aXRjaCBhZGIgc2VydmVyIHRvIHJvb3QgbW9kZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9mIHRoZSBzd2l0Y2ggd2FzIHN1Y2Nlc3NmdWwgb3IgZmFsc2VcbiAqICAgICAgICAgICAgICAgICAgIGlmIHRoZSBzd2l0Y2ggZmFpbGVkLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yb290ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsncm9vdCddKTtcblxuICAgIC8vIG9uIHJlYWwgZGV2aWNlcyBpbiBzb21lIHNpdHVhdGlvbnMgd2UgZ2V0IGFuIGVycm9yIGluIHRoZSBzdGRvdXRcbiAgICBpZiAoc3Rkb3V0ICYmIHN0ZG91dC5pbmRleE9mKCdhZGJkIGNhbm5vdCBydW4gYXMgcm9vdCcpICE9PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0ZG91dC50cmltKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvIHJvb3QgYWRiIGRhZW1vbjogJyR7ZXJyLm1lc3NhZ2V9Jy4gQ29udGludWluZ2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciB0byBub24tcm9vdCBtb2RlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb2YgdGhlIHN3aXRjaCB3YXMgc3VjY2Vzc2Z1bCBvciBmYWxzZVxuICogICAgICAgICAgICAgICAgICAgaWYgdGhlIHN3aXRjaCBmYWlsZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnVucm9vdCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbJ3Vucm9vdCddKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYFVuYWJsZSB0byB1bnJvb3QgYWRiIGRhZW1vbjogJyR7ZXJyLm1lc3NhZ2V9Jy4gQ29udGludWluZ2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCB1c2VyIGlzIHJvb3RcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB1c2VyIGlzIHJvb3RcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaWRlbnRpZnlpbmdcbiAqIHRoZSB1c2VyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pc1Jvb3QgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoYXdhaXQgdGhpcy5zaGVsbChbJ3dob2FtaSddKSkudHJpbSgpID09PSAncm9vdCc7XG59O1xuXG4vKipcbiAqIFZlcmlmeSB3aGV0aGVyIGEgcmVtb3RlIHBhdGggZXhpc3RzIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCB0byB2ZXJpZnkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiBwYXRoIGV4aXN0cyBvbiB0aGUgZGV2aWNlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5maWxlRXhpc3RzID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgpIHtcbiAgbGV0IGZpbGVzID0gYXdhaXQgdGhpcy5scyhyZW1vdGVQYXRoKTtcbiAgcmV0dXJuIGZpbGVzLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb3V0cHV0IG9mIF9sc18gY29tbWFuZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggKHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgX2xzXyBjb21tYW5kKS5cbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IG9wdHMgW1tdXSAtIEFkZGl0aW9uYWwgX2xzXyBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59IFRoZSBfbHNfIG91dHB1dCBhcyBhbiBhcnJheSBvZiBzcGxpdCBsaW5lcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCBvZiB0aGUgZ2l2ZW4gX3JlbW90ZVBhdGhfXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmxzID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgsIG9wdHMgPSBbXSkge1xuICB0cnkge1xuICAgIGxldCBhcmdzID0gWydscycsIC4uLm9wdHMsIHJlbW90ZVBhdGhdO1xuICAgIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKGFyZ3MpO1xuICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxuJyk7XG4gICAgcmV0dXJuIGxpbmVzLm1hcCgobCkgPT4gbC50cmltKCkpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuZmlsdGVyKChsKSA9PiBsLmluZGV4T2YoJ05vIHN1Y2ggZmlsZScpID09PSAtMSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHBhcnRpY3VsYXIgZmlsZSBsb2NhdGVkIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCB0byB0aGUgZmlsZS5cbiAqIEByZXR1cm4ge251bWJlcn0gRmlsZSBzaXplIGluIGJ5dGVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBmaWxlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5maWxlU2l6ZSA9IGFzeW5jIGZ1bmN0aW9uIChyZW1vdGVQYXRoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCB0aGlzLmxzKHJlbW90ZVBhdGgsIFsnLWxhJ10pO1xuICAgIGlmIChmaWxlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVtb3RlIHBhdGggaXMgbm90IGEgZmlsZWApO1xuICAgIH1cbiAgICAvLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL2ZPczRQNC84XG4gICAgY29uc3QgbWF0Y2ggPSAvW3J3eHNTdFRcXC0rXXsxMH1bXFxzXFxkXSpcXHNbXlxcc10rXFxzK1teXFxzXStcXHMrKFxcZCspLy5leGVjKGZpbGVzWzBdKTtcbiAgICBpZiAoIW1hdGNoIHx8IF8uaXNOYU4ocGFyc2VJbnQobWF0Y2hbMV0sIDEwKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHNpemUgZnJvbSBsaXN0IG91dHB1dDogJyR7ZmlsZXNbMF19J2ApO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZ2V0IGZpbGUgc2l6ZSBmb3IgJyR7cmVtb3RlUGF0aH0nOiAke2Vyci5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEluc3RhbGxzIHRoZSBnaXZlbiBjZXJ0aWZpY2F0ZSBvbiBhIHJvb3RlZCByZWFsIGRldmljZSBvclxuICogYW4gZW11bGF0b3IuIFRoZSBlbXVsYXRvciBtdXN0IGJlIGV4ZWN1dGVkIHdpdGggYC13cml0YWJsZS1zeXN0ZW1gXG4gKiBjb21tYW5kIGxpbmUgb3B0aW9uIGFuZCBhZGIgZGFlbW9uIHNob3VsZCBiZSBydW5uaW5nIGluIHJvb3RcbiAqIG1vZGUgZm9yIHRoaXMgbWV0aG9kIHRvIHdvcmsgcHJvcGVybHkuIFRoZSBtZXRob2QgYWxzbyByZXF1aXJlc1xuICogb3BlbnNzbCB0b29sIHRvIGJlIGF2YWlsYWJsZSBvbiB0aGUgZGVzdGluYXRpb24gc3lzdGVtLlxuICogUmVhZCBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL2FwcGl1bS9pc3N1ZXMvMTA5NjRcbiAqIGZvciBtb3JlIGRldGFpbHMgb24gdGhpcyB0b3BpY1xuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gY2VydCAtIGJhc2U2NC1kZWNvZGVkIGNvbnRlbnQgb2YgdGhlIGFjdHVhbCBjZXJ0aWZpY2F0ZVxuICogcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgb3IgYSBidWZmZXJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBvcGVuc3NsIHRvb2wgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgZGVzdGluYXRpb24gc3lzdGVtXG4gKiBvciBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaW5zdGFsbGluZyB0aGUgY2VydGlmaWNhdGVcbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuaW5zdGFsbE1pdG1DZXJ0aWZpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uIChjZXJ0KSB7XG4gIGNvbnN0IG9wZW5Tc2wgPSBhd2FpdCBnZXRPcGVuU3NsRm9yT3MoKTtcblxuICBpZiAoIV8uaXNCdWZmZXIoY2VydCkpIHtcbiAgICBjZXJ0ID0gQnVmZmVyLmZyb20oY2VydCwgJ2Jhc2U2NCcpO1xuICB9XG5cbiAgY29uc3QgdG1wUm9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICB0cnkge1xuICAgIGNvbnN0IHNyY0NlcnQgPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgJ3NvdXJjZS5jZXInKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoc3JjQ2VydCwgY2VydCk7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLCAnLW5vb3V0JywgJy1oYXNoJywgJy1pbicsIHNyY0NlcnRdKTtcbiAgICBjb25zdCBjZXJ0SGFzaCA9IHN0ZG91dC50cmltKCk7XG4gICAgbG9nLmRlYnVnKGBHb3QgY2VydGlmaWNhdGUgaGFzaDogJHtjZXJ0SGFzaH1gKTtcbiAgICBsb2cuZGVidWcoJ1ByZXBhcmluZyBjZXJ0aWZpY2F0ZSBjb250ZW50Jyk7XG4gICAgKHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLCAnLWluJywgc3JjQ2VydF0sIHtpc0J1ZmZlcjogdHJ1ZX0pKTtcbiAgICBsZXQgZHN0Q2VydENvbnRlbnQgPSBzdGRvdXQ7XG4gICAgKHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLFxuICAgICAgJy1pbicsIHNyY0NlcnQsXG4gICAgICAnLXRleHQnLFxuICAgICAgJy1maW5nZXJwcmludCcsXG4gICAgICAnLW5vb3V0J10sIHtpc0J1ZmZlcjogdHJ1ZX0pKTtcbiAgICBkc3RDZXJ0Q29udGVudCA9IEJ1ZmZlci5jb25jYXQoW2RzdENlcnRDb250ZW50LCBzdGRvdXRdKTtcbiAgICBjb25zdCBkc3RDZXJ0ID0gcGF0aC5yZXNvbHZlKHRtcFJvb3QsIGAke2NlcnRIYXNofS4wYCk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGRzdENlcnQsIGRzdENlcnRDb250ZW50KTtcbiAgICBsb2cuZGVidWcoJ1JlbW91bnRpbmcgL3N5c3RlbSBpbiBydyBtb2RlJyk7XG4gICAgLy8gU29tZXRpbWVzIGVtdWxhdG9yIHJlYm9vdCBpcyBzdGlsbCBub3QgZnVsbHkgZmluaXNoZWQgb24gdGhpcyBzdGFnZSwgc28gcmV0cnlcbiAgICBhd2FpdCByZXRyeUludGVydmFsKDUsIDIwMDAsIGFzeW5jICgpID0+IGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3JlbW91bnQnXSkpO1xuICAgIGxvZy5kZWJ1ZyhgVXBsb2FkaW5nIHRoZSBnZW5lcmF0ZWQgY2VydGlmaWNhdGUgZnJvbSAnJHtkc3RDZXJ0fScgdG8gJyR7Q0VSVFNfUk9PVH0nYCk7XG4gICAgYXdhaXQgdGhpcy5wdXNoKGRzdENlcnQsIENFUlRTX1JPT1QpO1xuICAgIGxvZy5kZWJ1ZygnUmVtb3VudGluZyAvc3lzdGVtIHRvIGNvbmZpcm0gY2hhbmdlcycpO1xuICAgIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3JlbW91bnQnXSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGluamVjdCB0aGUgY3VzdG9tIGNlcnRpZmljYXRlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYElzIHRoZSBjZXJ0aWZpY2F0ZSBwcm9wZXJseSBlbmNvZGVkIGludG8gYmFzZTY0LXN0cmluZz8gYCArXG4gICAgICAgICAgICAgICAgICAgIGBEbyB5b3UgaGF2ZSByb290IHBlcm1pc3Npb25zIG9uIHRoZSBkZXZpY2U/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcFJvb3QpO1xuICB9XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGlmIHRoZSBnaXZlbiByb290IGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkIG9uIHRoZSBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBjZXJ0IC0gYmFzZTY0LWRlY29kZWQgY29udGVudCBvZiB0aGUgYWN0dWFsIGNlcnRpZmljYXRlXG4gKiByZXByZXNlbnRlZCBhcyBhIHN0cmluZyBvciBhIGJ1ZmZlclxuICogQHRocm93cyB7RXJyb3J9IElmIG9wZW5zc2wgdG9vbCBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBkZXN0aW5hdGlvbiBzeXN0ZW1cbiAqIG9yIGlmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBjaGVja2luZyB0aGUgY2VydGlmaWNhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiBjZXJ0aWZpY2F0ZSBpcyBhbHJlYWR5IGluc3RhbGxlZFxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pc01pdG1DZXJ0aWZpY2F0ZUluc3RhbGxlZCA9IGFzeW5jIGZ1bmN0aW9uIChjZXJ0KSB7XG4gIGNvbnN0IG9wZW5Tc2wgPSBhd2FpdCBnZXRPcGVuU3NsRm9yT3MoKTtcblxuICBpZiAoIV8uaXNCdWZmZXIoY2VydCkpIHtcbiAgICBjZXJ0ID0gQnVmZmVyLmZyb20oY2VydCwgJ2Jhc2U2NCcpO1xuICB9XG5cbiAgY29uc3QgdG1wUm9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICBsZXQgY2VydEhhc2g7XG4gIHRyeSB7XG4gICAgY29uc3QgdG1wQ2VydCA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCAnc291cmNlLmNlcicpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0bXBDZXJ0LCBjZXJ0KTtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JywgJy1ub291dCcsICctaGFzaCcsICctaW4nLCB0bXBDZXJ0XSk7XG4gICAgY2VydEhhc2ggPSBzdGRvdXQudHJpbSgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXRyaWV2ZSB0aGUgY2VydGlmaWNhdGUgaGFzaC4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBJcyB0aGUgY2VydGlmaWNhdGUgcHJvcGVybHkgZW5jb2RlZCBpbnRvIGJhc2U2NC1zdHJpbmc/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcFJvb3QpO1xuICB9XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnBvc2l4LnJlc29sdmUoQ0VSVFNfUk9PVCwgYCR7Y2VydEhhc2h9LjBgKTtcbiAgbG9nLmRlYnVnKGBDaGVja2luZyBpZiB0aGUgY2VydGlmaWNhdGUgaXMgYWxyZWFkeSBpbnN0YWxsZWQgYXQgJyR7ZHN0UGF0aH0nYCk7XG4gIHJldHVybiBhd2FpdCB0aGlzLmZpbGVFeGlzdHMoZHN0UGF0aCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzeXN0ZW1DYWxsTWV0aG9kcztcbmV4cG9ydCB7IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVCB9O1xuIl0sImZpbGUiOiJsaWIvdG9vbHMvc3lzdGVtLWNhbGxzLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
