"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllUdids = getAllUdids;
exports.extensions = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _nodeSimctl = require("node-simctl");

var _logger = _interopRequireDefault(require("../logger"));

var _lodash = _interopRequireDefault(require("lodash"));

let extensions = {};
exports.extensions = extensions;

function getAllUdids() {
  return _getAllUdids.apply(this, arguments);
}

function _getAllUdids() {
  _getAllUdids = (0, _asyncToGenerator2.default)(function* () {
    let devices = yield (0, _nodeSimctl.getDevices)();
    return _lodash.default.chain(devices).values().flatten().map('udid').value();
  });
  return _getAllUdids.apply(this, arguments);
}

extensions.isolateSim = (0, _asyncToGenerator2.default)(function* () {
  _logger.default.debug("Isolating the requested simulator by deleting all others");

  let udids = yield getAllUdids();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _lodash.default.without(udids, this.udid)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      let udid = _step.value;
      yield (0, _nodeSimctl.deleteDevice)(udid);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
});require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9leHRlbnNpb25zL2lzb2xhdGUtc2ltLmpzIl0sIm5hbWVzIjpbImV4dGVuc2lvbnMiLCJnZXRBbGxVZGlkcyIsImRldmljZXMiLCJfIiwiY2hhaW4iLCJ2YWx1ZXMiLCJmbGF0dGVuIiwibWFwIiwidmFsdWUiLCJpc29sYXRlU2ltIiwibG9nIiwiZGVidWciLCJ1ZGlkcyIsIndpdGhvdXQiLCJ1ZGlkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFHQSxJQUFJQSxVQUFVLEdBQUcsRUFBakI7OztTQUVlQyxXOzs7OztpREFBZixhQUE4QjtBQUM1QixRQUFJQyxPQUFPLFNBQVMsNkJBQXBCO0FBRUEsV0FBT0MsZ0JBQUVDLEtBQUYsQ0FBUUYsT0FBUixFQUNKRyxNQURJLEdBRUpDLE9BRkksR0FHSkMsR0FISSxDQUdBLE1BSEEsRUFJSkMsS0FKSSxFQUFQO0FBS0QsRzs7OztBQUVEUixVQUFVLENBQUNTLFVBQVgsbUNBQXdCLGFBQWtCO0FBQ3hDQyxrQkFBSUMsS0FBSixDQUFVLDBEQUFWOztBQUNBLE1BQUlDLEtBQUssU0FBU1gsV0FBVyxFQUE3QjtBQUZ3QztBQUFBO0FBQUE7O0FBQUE7QUFJeEMseUJBQWlCRSxnQkFBRVUsT0FBRixDQUFVRCxLQUFWLEVBQWlCLEtBQUtFLElBQXRCLENBQWpCLDhIQUE4QztBQUFBLFVBQXJDQSxJQUFxQztBQUM1QyxZQUFNLDhCQUFhQSxJQUFiLENBQU47QUFDRDtBQU51QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT3pDLENBUEQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXREZXZpY2VzLCBkZWxldGVEZXZpY2UgfSBmcm9tICdub2RlLXNpbWN0bCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5cbmxldCBleHRlbnNpb25zID0ge307XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEFsbFVkaWRzICgpIHtcbiAgbGV0IGRldmljZXMgPSBhd2FpdCBnZXREZXZpY2VzKCk7XG5cbiAgcmV0dXJuIF8uY2hhaW4oZGV2aWNlcylcbiAgICAudmFsdWVzKClcbiAgICAuZmxhdHRlbigpXG4gICAgLm1hcCgndWRpZCcpXG4gICAgLnZhbHVlKCk7XG59XG5cbmV4dGVuc2lvbnMuaXNvbGF0ZVNpbSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKFwiSXNvbGF0aW5nIHRoZSByZXF1ZXN0ZWQgc2ltdWxhdG9yIGJ5IGRlbGV0aW5nIGFsbCBvdGhlcnNcIik7XG4gIGxldCB1ZGlkcyA9IGF3YWl0IGdldEFsbFVkaWRzKCk7XG5cbiAgZm9yIChsZXQgdWRpZCBvZiBfLndpdGhvdXQodWRpZHMsIHRoaXMudWRpZCkpIHtcbiAgICBhd2FpdCBkZWxldGVEZXZpY2UodWRpZCk7XG4gIH1cbn07XG5cblxuZXhwb3J0IHsgZXh0ZW5zaW9ucywgZ2V0QWxsVWRpZHMgfTtcbiJdLCJmaWxlIjoibGliL2V4dGVuc2lvbnMvaXNvbGF0ZS1zaW0uanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
