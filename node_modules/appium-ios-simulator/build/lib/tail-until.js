"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tailUntil = tailUntil;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _teen_process = require("teen_process");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _logger = _interopRequireDefault(require("./logger"));

function tailUntil(_x, _x2) {
  return _tailUntil.apply(this, arguments);
}

function _tailUntil() {
  _tailUntil = (0, _asyncToGenerator2.default)(function* (filePath, until, timeout = 5000) {
    let proc = new _teen_process.SubProcess('tail', ['-f', '-n', '100', filePath]);

    let startDetector = stdout => {
      return stdout.indexOf(until) > -1;
    };

    return yield new _bluebird.default((resolve, reject) => {
      let started = proc.start(startDetector);

      let timedout = _bluebird.default.delay(timeout).then(() => {
        return reject(new Error(`Tailing file ${filePath} failed after ${timeout}ms`));
      });

      _bluebird.default.race([started, timedout]).then(resolve).catch(reject);
    }).finally((0, _asyncToGenerator2.default)(function* () {
      if (proc.isRunning) {
        try {
          yield proc.stop();
        } catch (err) {
          _logger.default.info(`Stopping tail process failed: ${err.message}`);
        }
      }
    }));
  });
  return _tailUntil.apply(this, arguments);
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90YWlsLXVudGlsLmpzIl0sIm5hbWVzIjpbInRhaWxVbnRpbCIsImZpbGVQYXRoIiwidW50aWwiLCJ0aW1lb3V0IiwicHJvYyIsIlN1YlByb2Nlc3MiLCJzdGFydERldGVjdG9yIiwic3Rkb3V0IiwiaW5kZXhPZiIsIkIiLCJyZXNvbHZlIiwicmVqZWN0Iiwic3RhcnRlZCIsInN0YXJ0IiwidGltZWRvdXQiLCJkZWxheSIsInRoZW4iLCJFcnJvciIsInJhY2UiLCJjYXRjaCIsImZpbmFsbHkiLCJpc1J1bm5pbmciLCJzdG9wIiwiZXJyIiwibG9nIiwiaW5mbyIsIm1lc3NhZ2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O1NBR2VBLFM7Ozs7OytDQUFmLFdBQTBCQyxRQUExQixFQUFvQ0MsS0FBcEMsRUFBMkNDLE9BQU8sR0FBRyxJQUFyRCxFQUEyRDtBQUN6RCxRQUFJQyxJQUFJLEdBQUcsSUFBSUMsd0JBQUosQ0FBZSxNQUFmLEVBQXVCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxLQUFiLEVBQW9CSixRQUFwQixDQUF2QixDQUFYOztBQVFBLFFBQUlLLGFBQWEsR0FBSUMsTUFBRCxJQUFZO0FBQzlCLGFBQU9BLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlTixLQUFmLElBQXdCLENBQUMsQ0FBaEM7QUFDRCxLQUZEOztBQUlBLGlCQUFhLElBQUlPLGlCQUFKLENBQU0sQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDLFVBQUlDLE9BQU8sR0FBR1IsSUFBSSxDQUFDUyxLQUFMLENBQVdQLGFBQVgsQ0FBZDs7QUFHQSxVQUFJUSxRQUFRLEdBQUdMLGtCQUFFTSxLQUFGLENBQVFaLE9BQVIsRUFBaUJhLElBQWpCLENBQXNCLE1BQU07QUFDekMsZUFBT0wsTUFBTSxDQUFDLElBQUlNLEtBQUosQ0FBVyxnQkFBZWhCLFFBQVMsaUJBQWdCRSxPQUFRLElBQTNELENBQUQsQ0FBYjtBQUNELE9BRmMsQ0FBZjs7QUFLQU0sd0JBQUVTLElBQUYsQ0FBTyxDQUFDTixPQUFELEVBQVVFLFFBQVYsQ0FBUCxFQUE0QkUsSUFBNUIsQ0FBaUNOLE9BQWpDLEVBQTBDUyxLQUExQyxDQUFnRFIsTUFBaEQ7QUFDRCxLQVZZLEVBVVZTLE9BVlUsaUNBVUYsYUFBWTtBQUVyQixVQUFJaEIsSUFBSSxDQUFDaUIsU0FBVCxFQUFvQjtBQUNsQixZQUFJO0FBQ0YsZ0JBQU1qQixJQUFJLENBQUNrQixJQUFMLEVBQU47QUFDRCxTQUZELENBRUUsT0FBT0MsR0FBUCxFQUFZO0FBRVpDLDBCQUFJQyxJQUFKLENBQVUsaUNBQWdDRixHQUFHLENBQUNHLE9BQVEsRUFBdEQ7QUFDRDtBQUNGO0FBQ0YsS0FwQlksRUFBYjtBQXFCRCxHIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcblxuLy8gdGFpbHMgYSBmaWxlLCBwcm9taXNlIHJlc29sdmVzIHdoZW4gaW5wdXQgc3RyaW5nIGlzIHdyaXR0ZW4gdG8gZmlsZVxuYXN5bmMgZnVuY3Rpb24gdGFpbFVudGlsIChmaWxlUGF0aCwgdW50aWwsIHRpbWVvdXQgPSA1MDAwKSB7XG4gIGxldCBwcm9jID0gbmV3IFN1YlByb2Nlc3MoJ3RhaWwnLCBbJy1mJywgJy1uJywgJzEwMCcsIGZpbGVQYXRoXSk7XG5cbiAgLy8gLy8gZm9yIGRlYnVnZ2luZ1xuICAvLyBmdW5jdGlvbiBjb25zb2xlT3V0ICguLi5hcmdzKSB7XG4gIC8vICAgY29uc29sZS5sb2coYD4+PiAke2FyZ3N9YCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAvLyB9XG4gIC8vIHByb2Mub24oJ291dHB1dCcsIGNvbnNvbGVPdXQpO1xuXG4gIGxldCBzdGFydERldGVjdG9yID0gKHN0ZG91dCkgPT4ge1xuICAgIHJldHVybiBzdGRvdXQuaW5kZXhPZih1bnRpbCkgPiAtMTtcbiAgfTtcblxuICByZXR1cm4gYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBzdGFydGVkID0gcHJvYy5zdGFydChzdGFydERldGVjdG9yKTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLXRoZW4gKi9cbiAgICBsZXQgdGltZWRvdXQgPSBCLmRlbGF5KHRpbWVvdXQpLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYFRhaWxpbmcgZmlsZSAke2ZpbGVQYXRofSBmYWlsZWQgYWZ0ZXIgJHt0aW1lb3V0fW1zYCkpO1xuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgIEIucmFjZShbc3RhcnRlZCwgdGltZWRvdXRdKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gIH0pLmZpbmFsbHkoYXN5bmMgKCkgPT4ge1xuICAgIC8vIG5vIG1hdHRlciB3aGF0LCBzdG9wIHRoZSB0YWlsIHByb2Nlc3NcbiAgICBpZiAocHJvYy5pc1J1bm5pbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb2Muc3RvcCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vdCBtdWNoIHdlIGNhbiBkbyBoZXJlLCB1bmZvcnR1bmF0ZWx5LCBidXQgbG9nXG4gICAgICAgIGxvZy5pbmZvKGBTdG9wcGluZyB0YWlsIHByb2Nlc3MgZmFpbGVkOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IHRhaWxVbnRpbCB9O1xuIl0sImZpbGUiOiJsaWIvdGFpbC11bnRpbC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
